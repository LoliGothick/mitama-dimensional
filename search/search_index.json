{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \"Don't trust what you compile in your brain unless you know where wording of standard is.\" Motivation In real world, we treat dimensional quantities (length, mass, time, ...). And we know that addition and subtraction of quantities with different dimensions like 1 m + 2 kg do not make sense. Because we use a statically typed programming language C++, expressions that do not make sense should be ill-formed. Consequently, the natural idea of \u200b\u200bexpressing and distinguishing dimensions by types comes out. C++ Units Libraries already exist (e.g. Boost.Units). However, these libraries have the problem that the quantities that can be represent are limited to Physical Quantities . This library proposes a type system that does not limit available dimensions. In this library, it becomes possible to handle physical quantities and user defined dimensions (e.g. currency) in an integrated syntax. In addition, Mitama.Dimensional takes advantage of C++17 features/libraries and provides better syntax than the conventional Units libraries.","title":"Home"},{"location":"#introduction","text":"\"Don't trust what you compile in your brain unless you know where wording of standard is.\"","title":"Introduction"},{"location":"#motivation","text":"In real world, we treat dimensional quantities (length, mass, time, ...). And we know that addition and subtraction of quantities with different dimensions like 1 m + 2 kg do not make sense. Because we use a statically typed programming language C++, expressions that do not make sense should be ill-formed. Consequently, the natural idea of \u200b\u200bexpressing and distinguishing dimensions by types comes out. C++ Units Libraries already exist (e.g. Boost.Units). However, these libraries have the problem that the quantities that can be represent are limited to Physical Quantities . This library proposes a type system that does not limit available dimensions. In this library, it becomes possible to handle physical quantities and user defined dimensions (e.g. currency) in an integrated syntax. In addition, Mitama.Dimensional takes advantage of C++17 features/libraries and provides better syntax than the conventional Units libraries.","title":"Motivation"},{"location":"CONTRIBUTION/","text":"Contribution Guide Any contribution to Mitama.Dimensional is more than welcome! Reporting Issues The best way to contribute to this project is to send a detailed report when you encounter a problem. It is preferable to minimize the code as much as possible in problematic situations. Then include in the report the error code and environment (OS, compiler and its version, compile options) and the error message without omission. Pull request Pull requests are welcome, even if they are just a typo fix! However, any significant improvements should be related to the existing feature request or bug report. Start Clone this repository locally. Initialize submodule with command as follows: $ git sbumodule update --init --recursive The library does not depend on Boost, but the tests use Boost. Although we do not use the Boost library that needs to be built, we recommend that you install it so that CMake will automatically find it (Please refer to Boost Wiki ). The other tool you need besides the C ++ compiler to test is CMake. Please install CMake-3.1 or later which can specify C++17. Unit tests Test is located under tests directory in the repository root. There is a CMakeLists.txt file in repository root. Perform an outsource build as follows: $ mkdir build $ cd build $ cmake .. $ make -j10 $ ctest Examples If you are implementing a new feature, add sample code to examples/ . This will help us understand the changes a lot and help Mitama.Dimensional users understand your well-organized features. Documentation If you add a new feature, you will probably want to change the document. Please send PR to feature/gitbook . Of course, typo and minor wording fixes are also welcome.","title":"Contribution"},{"location":"CONTRIBUTION/#contribution-guide","text":"Any contribution to Mitama.Dimensional is more than welcome!","title":"Contribution Guide"},{"location":"CONTRIBUTION/#reporting-issues","text":"The best way to contribute to this project is to send a detailed report when you encounter a problem. It is preferable to minimize the code as much as possible in problematic situations. Then include in the report the error code and environment (OS, compiler and its version, compile options) and the error message without omission.","title":"Reporting Issues"},{"location":"CONTRIBUTION/#pull-request","text":"Pull requests are welcome, even if they are just a typo fix! However, any significant improvements should be related to the existing feature request or bug report.","title":"Pull request"},{"location":"CONTRIBUTION/#start","text":"Clone this repository locally. Initialize submodule with command as follows: $ git sbumodule update --init --recursive The library does not depend on Boost, but the tests use Boost. Although we do not use the Boost library that needs to be built, we recommend that you install it so that CMake will automatically find it (Please refer to Boost Wiki ). The other tool you need besides the C ++ compiler to test is CMake. Please install CMake-3.1 or later which can specify C++17.","title":"Start"},{"location":"CONTRIBUTION/#unit-tests","text":"Test is located under tests directory in the repository root. There is a CMakeLists.txt file in repository root. Perform an outsource build as follows: $ mkdir build $ cd build $ cmake .. $ make -j10 $ ctest","title":"Unit tests"},{"location":"CONTRIBUTION/#examples","text":"If you are implementing a new feature, add sample code to examples/ . This will help us understand the changes a lot and help Mitama.Dimensional users understand your well-organized features.","title":"Examples"},{"location":"CONTRIBUTION/#documentation","text":"If you add a new feature, you will probably want to change the document. Please send PR to feature/gitbook . Of course, typo and minor wording fixes are also welcome.","title":"Documentation"},{"location":"Reference/arithmetic/","text":"Arithmetic operator + operator + for quantities. Note This operator shall not participates in overload resolution unless std::conjunction_v<is_same_dimensional_v<std::decay_t<L>, std::decay_t<R>>, is_addable<typename std::decay_t<L>::value_type, typename std::decay_t<R>::value_type>> is true . template < class L , class R , std :: enable_if_t < is_same_dimensional_v < std :: decay_t < L > , std :: decay_t < R >> , bool > = false > constexpr auto operator + ( L && lhs , R && rhs ) { using result_type = std :: common_type_t < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type > ; return quantity_t < mitamagic :: scaled_demension_t < typename std :: decay_t < L >:: dimension_type , typename std :: decay_t < R >:: dimension_type > , result_type > { mitamagic :: scaled_value ( std :: forward < L > ( lhs ), std :: forward < R > ( rhs ), []( auto a , auto b ){ return a + b ; }) }; } operator - template < class L , class R , std :: enable_if_t < is_same_dimensional_v < std :: decay_t < L > , std :: decay_t < R >> , bool > = false > constexpr auto operator - ( L && lhs , R && rhs ) { using result_type = std :: common_type_t < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type > ; return quantity_t < mitamagic :: scaled_demension_t < typename std :: decay_t < L >:: dimension_type , typename std :: decay_t < R >:: dimension_type > , result_type > { mitamagic :: scaled_value ( std :: forward < L > ( lhs ), std :: forward < R > ( rhs ), []( auto a , auto b ){ return a - b ; }) }; } operator * template < class L , class R , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < L >> , is_quantity < std :: decay_t < R >>> , bool > = false > constexpr auto operator * ( L && lhs , R && rhs ) { return quantity_t < mitamagic :: quotient_t < typename std :: decay_t < L >:: dimension_type , typename std :: decay_t < R >:: dimension_type > , std :: common_type_t < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type >> { mitamagic :: scaled_value ( std :: forward < L > ( lhs ), std :: forward < R > ( rhs ), []( auto a , auto b ){ return a * b ; }) }; } template < class L , std :: enable_if_t < is_quantity_v < std :: decay_t < L >> , bool > = false > constexpr auto operator * ( L && lhs , typename std :: decay_t < L >:: value_type const & rhs ) { return std :: decay_t < L > ( std :: forward < L > ( lhs ). get () * rhs ); } template < class R , std :: enable_if_t < is_quantity_v < std :: decay_t < R >> , bool > = false > constexpr auto operator * ( typename std :: decay_t < R >:: value_type const & lhs , R && rhs ) { return std :: decay_t < R > ( std :: forward < R > ( rhs ). get () * lhs ); } operator / template < class L , class R , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < L >> , is_quantity < std :: decay_t < R >>> , bool > = false > constexpr auto operator / ( L && lhs , R && rhs ) { return quantity_t < mitamagic :: quotient_t < typename std :: decay_t < L >:: dimension_type , mitamagic :: inverse_t < typename std :: decay_t < R >:: dimension_type >> , std :: common_type_t < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type > > { mitamagic :: scaled_value ( std :: forward < L > ( lhs ), std :: forward < R > ( rhs ), []( auto a , auto b ){ return a / b ; }) }; } template < class L , std :: enable_if_t < is_quantity_v < std :: decay_t < L >> , bool > = false > constexpr auto operator / ( L && lhs , typename std :: decay_t < L >:: value_type const & rhs ) { return std :: decay_t < L > ( std :: forward < L > ( lhs ). get () / rhs ); } template < class R , std :: enable_if_t < is_quantity_v < std :: decay_t < R >> , bool > = false > constexpr auto operator / ( typename std :: decay_t < R >:: value_type const & lhs , R && rhs ) { return quantity_t < si_base_units_repr < mitamagic :: inverse_t < typename std :: decay_t < R >:: dimension_type >> , typename std :: decay_t < R >:: value_type > ( lhs / std :: forward < R > ( rhs ). get ()); }","title":"arithmetic"},{"location":"Reference/arithmetic/#arithmetic","text":"","title":"Arithmetic"},{"location":"Reference/arithmetic/#operator","text":"operator + for quantities. Note This operator shall not participates in overload resolution unless std::conjunction_v<is_same_dimensional_v<std::decay_t<L>, std::decay_t<R>>, is_addable<typename std::decay_t<L>::value_type, typename std::decay_t<R>::value_type>> is true . template < class L , class R , std :: enable_if_t < is_same_dimensional_v < std :: decay_t < L > , std :: decay_t < R >> , bool > = false > constexpr auto operator + ( L && lhs , R && rhs ) { using result_type = std :: common_type_t < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type > ; return quantity_t < mitamagic :: scaled_demension_t < typename std :: decay_t < L >:: dimension_type , typename std :: decay_t < R >:: dimension_type > , result_type > { mitamagic :: scaled_value ( std :: forward < L > ( lhs ), std :: forward < R > ( rhs ), []( auto a , auto b ){ return a + b ; }) }; }","title":"operator +"},{"location":"Reference/arithmetic/#operator-","text":"template < class L , class R , std :: enable_if_t < is_same_dimensional_v < std :: decay_t < L > , std :: decay_t < R >> , bool > = false > constexpr auto operator - ( L && lhs , R && rhs ) { using result_type = std :: common_type_t < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type > ; return quantity_t < mitamagic :: scaled_demension_t < typename std :: decay_t < L >:: dimension_type , typename std :: decay_t < R >:: dimension_type > , result_type > { mitamagic :: scaled_value ( std :: forward < L > ( lhs ), std :: forward < R > ( rhs ), []( auto a , auto b ){ return a - b ; }) }; }","title":"operator -"},{"location":"Reference/arithmetic/#operator_1","text":"template < class L , class R , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < L >> , is_quantity < std :: decay_t < R >>> , bool > = false > constexpr auto operator * ( L && lhs , R && rhs ) { return quantity_t < mitamagic :: quotient_t < typename std :: decay_t < L >:: dimension_type , typename std :: decay_t < R >:: dimension_type > , std :: common_type_t < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type >> { mitamagic :: scaled_value ( std :: forward < L > ( lhs ), std :: forward < R > ( rhs ), []( auto a , auto b ){ return a * b ; }) }; } template < class L , std :: enable_if_t < is_quantity_v < std :: decay_t < L >> , bool > = false > constexpr auto operator * ( L && lhs , typename std :: decay_t < L >:: value_type const & rhs ) { return std :: decay_t < L > ( std :: forward < L > ( lhs ). get () * rhs ); } template < class R , std :: enable_if_t < is_quantity_v < std :: decay_t < R >> , bool > = false > constexpr auto operator * ( typename std :: decay_t < R >:: value_type const & lhs , R && rhs ) { return std :: decay_t < R > ( std :: forward < R > ( rhs ). get () * lhs ); }","title":"operator *"},{"location":"Reference/arithmetic/#operator_2","text":"template < class L , class R , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < L >> , is_quantity < std :: decay_t < R >>> , bool > = false > constexpr auto operator / ( L && lhs , R && rhs ) { return quantity_t < mitamagic :: quotient_t < typename std :: decay_t < L >:: dimension_type , mitamagic :: inverse_t < typename std :: decay_t < R >:: dimension_type >> , std :: common_type_t < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type > > { mitamagic :: scaled_value ( std :: forward < L > ( lhs ), std :: forward < R > ( rhs ), []( auto a , auto b ){ return a / b ; }) }; } template < class L , std :: enable_if_t < is_quantity_v < std :: decay_t < L >> , bool > = false > constexpr auto operator / ( L && lhs , typename std :: decay_t < L >:: value_type const & rhs ) { return std :: decay_t < L > ( std :: forward < L > ( lhs ). get () / rhs ); } template < class R , std :: enable_if_t < is_quantity_v < std :: decay_t < R >> , bool > = false > constexpr auto operator / ( typename std :: decay_t < R >:: value_type const & lhs , R && rhs ) { return quantity_t < si_base_units_repr < mitamagic :: inverse_t < typename std :: decay_t < R >:: dimension_type >> , typename std :: decay_t < R >:: value_type > ( lhs / std :: forward < R > ( rhs ). get ()); }","title":"operator /"},{"location":"Reference/quantity/","text":"class quantity Constructors and Destructors default constructor constexpr quantity_t () : value_ {} {} Constructors for value Initializes the contained value as if in-place-initializing with expression T(std::forward<Args>(args)...) . template < class U , std :: enable_if_t < std :: is_constructible_v < T , U > && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t ( U && u ) : value_ ( std :: forward < U > ( u )) {} template < class U , std :: enable_if_t < std :: is_constructible_v < T , U > && ! std :: is_convertible_v < U , T > , bool > = false > explicit constexpr quantity_t ( U && u ) : value_ { std :: forward < U > ( u )} {} Copy constructors for linear scale quantities Initializes the contained value from o.value , and conversion factor is calculated automatically. template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> && std :: is_constructible_v < T , U > && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t ( quantity_t < D , U > const & o ) : value_ ( mitamagic :: converted_value < quantity_t > ( o )) {} template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> && std :: is_constructible_v < T , U > && ! std :: is_convertible_v < U , T > , bool > = false > explicit constexpr quantity_t ( quantity_t < D , U > const & o ) : value_ { mitamagic :: converted_value < quantity_t > ( o )} {} Copy constructors for non-linear scale quantities Initializes contained value using converter . This constructor may shall call between absolute temperature and celsius temperature or between radian and celsius angle. template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> && std :: is_constructible_v < T , U > && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t ( quantity_t < D , U > const & o ) : value_ ( :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o )) {} template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> && std :: is_constructible_v < T , U > && ! std :: is_convertible_v < U , T > , bool > = false > explicit constexpr quantity_t ( quantity_t < D , U > const & o ) : value_ { :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o )} {} Copy assignment operator Copy initializes the contained value from o.value and conversion factor is calculated automatically. template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t & operator = ( quantity_t < D , U > const & o ) & { this -> value_ = mitamagic :: converted_value < quantity_t > ( o ); return * this ; } template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t & operator = ( quantity_t < D , U > const & o ) & { this -> value_ = :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); return * this ; } Comparisons Note This operator shall not participate in overload resolution unless is_{xxx}_comparable<T, U> is true. {xxx} denotes equal ( == ), not_equal ( != ), less ( < ), less_or_equal ( <= ), greater ( > ) or greater_or_equal ( >= ). operator == template < class D , class U , std :: enable_if_t < std :: conjunction_v < is_complete_type <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , is_equal_comparable < T , U >> , bool > = false > constexpr bool operator == ( quantity_t < D , U > const & o ) const { return this -> value_ == :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < std :: conjunction_v < is_same_dimensional < quantity_t , quantity_t < D , U >> , is_equal_comparable < T , U >> , bool > = false > constexpr bool operator == ( quantity_t < D , U > const & o ) const { return this -> value_ == mitamagic :: converted_value < quantity_t > ( o ); } operator != template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator != ( quantity_t < D , U > const & o ) const { return this -> value_ != :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator != ( quantity_t < D , U > const & o ) const { return this -> value_ != mitamagic :: converted_value < quantity_t > ( o ); } operator < template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator < ( quantity_t < D , U > const & o ) const { return this -> value_ < :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator < ( quantity_t < D , U > const & o ) const { return this -> value_ < mitamagic :: converted_value < quantity_t > ( o ); } operator <= template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator <= ( quantity_t < D , U > const & o ) const { return this -> value_ <= :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator <= ( quantity_t < D , U > const & o ) const { return this -> value_ <= mitamagic :: converted_value < quantity_t > ( o ); } operator > template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator > ( quantity_t < D , U > const & o ) const { return this -> value_ > :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator > ( quantity_t < D , U > const & o ) const { return this -> value_ > mitamagic :: converted_value < quantity_t > ( o ); } operator >= template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator >= ( quantity_t < D , U > const & o ) const { return this -> value_ >= :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator >= ( quantity_t < D , U > const & o ) const { return this -> value_ >= mitamagic :: converted_value < quantity_t > ( o ); } Accessor value() Returns contained value. constexpr T value () const { return value_ ; } operator | for dimensional quantifier It is allowed to convert values into quantities by piping a value to dimensional quantifiers. // begin example #include <dimensional/quantity.hpp> #include <dimensional/si_units/all.hpp> int main () { namespace si = mitama :: si ; using mitama :: quantity_t ; // using template argument deduction for class templates quantity_t mass = 3 | si :: kilograms ; // 3 [kg] quantity_t time = 1.66 | si :: seconds ; // 1.66 [s] quantity_t volume = 4 | si :: meter < 3 > ; // 4 [m^3] // ^~~ variable template } // end example","title":"class quantity_t"},{"location":"Reference/quantity/#class-quantity","text":"","title":"class quantity"},{"location":"Reference/quantity/#constructors-and-destructors","text":"","title":"Constructors and Destructors"},{"location":"Reference/quantity/#default-constructor","text":"constexpr quantity_t () : value_ {} {}","title":"default constructor"},{"location":"Reference/quantity/#constructors-for-value","text":"Initializes the contained value as if in-place-initializing with expression T(std::forward<Args>(args)...) . template < class U , std :: enable_if_t < std :: is_constructible_v < T , U > && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t ( U && u ) : value_ ( std :: forward < U > ( u )) {} template < class U , std :: enable_if_t < std :: is_constructible_v < T , U > && ! std :: is_convertible_v < U , T > , bool > = false > explicit constexpr quantity_t ( U && u ) : value_ { std :: forward < U > ( u )} {}","title":"Constructors for value"},{"location":"Reference/quantity/#copy-constructors-for-linear-scale-quantities","text":"Initializes the contained value from o.value , and conversion factor is calculated automatically. template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> && std :: is_constructible_v < T , U > && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t ( quantity_t < D , U > const & o ) : value_ ( mitamagic :: converted_value < quantity_t > ( o )) {} template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> && std :: is_constructible_v < T , U > && ! std :: is_convertible_v < U , T > , bool > = false > explicit constexpr quantity_t ( quantity_t < D , U > const & o ) : value_ { mitamagic :: converted_value < quantity_t > ( o )} {}","title":"Copy constructors for linear scale quantities"},{"location":"Reference/quantity/#copy-constructors-for-non-linear-scale-quantities","text":"Initializes contained value using converter . This constructor may shall call between absolute temperature and celsius temperature or between radian and celsius angle. template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> && std :: is_constructible_v < T , U > && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t ( quantity_t < D , U > const & o ) : value_ ( :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o )) {} template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> && std :: is_constructible_v < T , U > && ! std :: is_convertible_v < U , T > , bool > = false > explicit constexpr quantity_t ( quantity_t < D , U > const & o ) : value_ { :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o )} {}","title":"Copy constructors for non-linear scale quantities"},{"location":"Reference/quantity/#copy-assignment-operator","text":"Copy initializes the contained value from o.value and conversion factor is calculated automatically. template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t & operator = ( quantity_t < D , U > const & o ) & { this -> value_ = mitamagic :: converted_value < quantity_t > ( o ); return * this ; } template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t & operator = ( quantity_t < D , U > const & o ) & { this -> value_ = :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); return * this ; }","title":"Copy assignment operator"},{"location":"Reference/quantity/#comparisons","text":"Note This operator shall not participate in overload resolution unless is_{xxx}_comparable<T, U> is true. {xxx} denotes equal ( == ), not_equal ( != ), less ( < ), less_or_equal ( <= ), greater ( > ) or greater_or_equal ( >= ).","title":"Comparisons"},{"location":"Reference/quantity/#operator","text":"template < class D , class U , std :: enable_if_t < std :: conjunction_v < is_complete_type <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , is_equal_comparable < T , U >> , bool > = false > constexpr bool operator == ( quantity_t < D , U > const & o ) const { return this -> value_ == :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < std :: conjunction_v < is_same_dimensional < quantity_t , quantity_t < D , U >> , is_equal_comparable < T , U >> , bool > = false > constexpr bool operator == ( quantity_t < D , U > const & o ) const { return this -> value_ == mitamagic :: converted_value < quantity_t > ( o ); }","title":"operator =="},{"location":"Reference/quantity/#operator_1","text":"template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator != ( quantity_t < D , U > const & o ) const { return this -> value_ != :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator != ( quantity_t < D , U > const & o ) const { return this -> value_ != mitamagic :: converted_value < quantity_t > ( o ); }","title":"operator !="},{"location":"Reference/quantity/#operator_2","text":"template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator < ( quantity_t < D , U > const & o ) const { return this -> value_ < :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator < ( quantity_t < D , U > const & o ) const { return this -> value_ < mitamagic :: converted_value < quantity_t > ( o ); }","title":"operator &lt;"},{"location":"Reference/quantity/#operator_3","text":"template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator <= ( quantity_t < D , U > const & o ) const { return this -> value_ <= :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator <= ( quantity_t < D , U > const & o ) const { return this -> value_ <= mitamagic :: converted_value < quantity_t > ( o ); }","title":"operator &lt;="},{"location":"Reference/quantity/#operator_4","text":"template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator > ( quantity_t < D , U > const & o ) const { return this -> value_ > :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator > ( quantity_t < D , U > const & o ) const { return this -> value_ > mitamagic :: converted_value < quantity_t > ( o ); }","title":"operator &gt;"},{"location":"Reference/quantity/#operator_5","text":"template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator >= ( quantity_t < D , U > const & o ) const { return this -> value_ >= :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator >= ( quantity_t < D , U > const & o ) const { return this -> value_ >= mitamagic :: converted_value < quantity_t > ( o ); }","title":"operator &gt;="},{"location":"Reference/quantity/#accessor","text":"","title":"Accessor"},{"location":"Reference/quantity/#value","text":"Returns contained value. constexpr T value () const { return value_ ; }","title":"value()"},{"location":"Reference/quantity/#operator-for-dimensional-quantifier","text":"It is allowed to convert values into quantities by piping a value to dimensional quantifiers. // begin example #include <dimensional/quantity.hpp> #include <dimensional/si_units/all.hpp> int main () { namespace si = mitama :: si ; using mitama :: quantity_t ; // using template argument deduction for class templates quantity_t mass = 3 | si :: kilograms ; // 3 [kg] quantity_t time = 1.66 | si :: seconds ; // 1.66 [s] quantity_t volume = 4 | si :: meter < 3 > ; // 4 [m^3] // ^~~ variable template } // end example","title":"operator | for dimensional quantifier"},{"location":"UserManual/basic-concepts/","text":"Basic Concepts \"It is the undefined-behavior we fear when we look upon death and darkness, nothing more.\" TL;DR mitama::quantity_t is a class template that is represents dimensional quantity. quantity_t has units as a phantom type. It can handle rational exponents like m ^ {2/3} as a unit. In the following are the explanations of the detailed definitions, their techniques, and metaprogramming, but if you are not interested, please proceed to the next page. Representation of Unit Basic unit of a dimension \\lambda with exponent and scale is represented as a pair of exponent e \\in \\mathbb{Q} and scale s \\in \\mathbb{Q} : U_\\lambda := (e, s)_{\\lambda} for example, m = (1, 1)_{length} \\\\ mm = (1, 1/1000)_{length} \\\\ mm^{2/3} = (2/3, 1/1000)_{length} This corresponds to units_t in Mitama.Dimensional. Representation of Derived Unit Let \\Lambda is a set of basic dimensions of Derived Unit, derived units is represented as a sets of Unit over \\Lambda : D_\\Lambda := {\\{U_\\lambda\\}}_{\\lambda \\in \\Lambda} for example, N = kg \\cdot m^2 \\cdot s^{-2} = \\{ (1, 1)_{mass}, (2, 1)_{length}, (-2, 1)_{time} \\} This corresponds to dimensional_t in Mitama.Dimensional. Type System of Quantity Dimensional quantity is designed as quantity_t , which is a class that represents a dimensional quantity based on ValueType that is distinguished by a phantom type dimensional_t<Units...> : template < template < class > class Synonym , class ValueType , class ... Units > class quantity_t < Synonym < dimensional_t < Units ... >> , ValueType > Synonym is a phantom template template for aliasing. And each type of Units... is designed as units_t : template < class BaseDimension , // base dimension tag class class Exponent , // std::ratio class Scale // std::ratio > class units_t < BaseDimension , Exponent , Scale > Tracking units and conversion factors in types When value a has derived unit D_\\Lambda , let that be denoted as: a: D_\\Lambda then (a:A_\\Lambda) \\pm (b:B_\\Lambda) = a \\pm b:{\\{ ( e, min(s_a, s_b) )_{\\lambda} \\ | \\ (e_a, s_a)_{\\lambda} \\in A_\\Lambda, (e_b, s_b)_{\\lambda} \\in B_\\Lambda \\}}_{\\lambda \\in \\Lambda} min (s_a, s_b) means it is automatically converted to a high precision factor. // `a` = 1 mm quantity_t < millimetre_t > a = 1 ; // `b` = 1 m quantity_t < metre_t > b = 1 ; // a + b will be millimetre a + b ; // 1001 mm (a:A_{\\Gamma}) \\times (b:B_{\\Lambda}) = a \\times b: {\\{ ( e_a + e_b, min(s_a, s_b) )_{\\sigma} \\ | \\ (e_a, s_a)_{\\sigma} \\in A_\\sigma, (e_b, s_b)_{\\sigma} \\in B_\\sigma \\}}_{\\sigma \\in \\Gamma \\cap \\Lambda } \\\\ \\cup {\\{ (e_a, s_a)_{\\gamma} \\ | \\ (e_a, s_a)_{\\gamma} \\in A_\\gamma\\}}_{\\gamma \\in \\Gamma \\backslash \\Lambda } \\\\ \\cup {\\{ (e_b, s_b)_{\\lambda} \\ | \\ (e_b, s_b)_{\\lambda} \\in B_\\lambda\\}}_{\\lambda \\in \\Lambda \\backslash \\Gamma } It is automatically converted to a high precision factor, too. (a:A_{\\Gamma}) \\div (b:B_{\\Lambda}) define {D_\\Lambda}^{-1} := {\\{ (-e, s)_{\\lambda} \\ | \\ (e, s)_{\\lambda} \\in D_\\Lambda \\}}_{\\lambda \\in \\Lambda} and (a:A_{\\Gamma}) \\div (b:B_{\\Lambda}) := (a:A_{\\Gamma}) \\times (b^{-1}:{B_{\\Lambda}}^{-1}) Algorithm of dimension inducing Example: [m^2 \\cdot s^{-1}] \\times [kg \\cdot s^{-1}] \\leadsto [m^2 \\cdot s^{-2} \\cdot kg] First, let mul(U_1, U_2) := (e_1 + e_2, min(s_1, s_2))_\\lambda And we consider simple dual loop: Pick a unit_t A from left. If there is a right for B with the same dimensions as A , push If there is a right for B with the same dimensions as A , push mul(A, B) to result and pop A and remove B from right, else push A to result and pop A . If left does not empty, return to 1, else push the rest of right to result Start with: left = [m^2 \\cdot s^{-1}] \\\\ right = [kg \\cdot s^{-1}] \\\\ result = [\\ ] Pick A=m^2 , and not found B. Then, we push m^2 to result and pop m^2 from left. left = [s^{-1}] \\\\ right = [kg \\cdot s^{-1}] \\\\ result = [m^2] Pick A=s^{-1} , found B=s^{-1} . Then, we push s^{-1} to result, pop s^{-1} from left, and pop s^{-1} from right. left = [\\ ] \\\\ right = [kg] \\\\ result = [m^2 \\cdot s^{-2}] Now, left is empty. So we push the rest units of right to result. left = [\\ ] \\\\ right = [\\ ] \\\\ result = [m^2 \\cdot s^{-2} \\cdot kg] Finally, we get the result [m^2 \\cdot s^{-2} \\cdot kg] -- end example Dive into type-level programing 1st step: Implementing in runtime When you do type-level programming, do you suddenly declare classes? It's a good idea to start by identifying what you need for type-level programming through runtime programming. Well, I usually declare classes suddenly. Here is the runtime code that derives the result of the unit multiplication described in the example above: Wandbox // This file is a \"Hello, world!\" in C++ language by Clang for wandbox. #include <bits/stdc++.h> #include <boost/rational.hpp> #include <boost/format.hpp> enum class Dim { mass , time , length , //... }; bool operator == ( Dim a , Dim b ) { return static_cast < std :: underlying_type_t < Dim >> ( a ) == static_cast < std :: underlying_type_t < Dim >> ( b ); } std :: ostream & operator << ( std :: ostream & os , Dim b ) { switch ( b ) { case Dim :: time : return os << \"time\" ; case Dim :: mass : return os << \"mass\" ; case Dim :: length : return os << \"length\" ; default : return os ; } } using rational = boost :: rational < std :: intmax_t > ; using U = std :: pair < const Dim , std :: pair < rational , rational >> ; using derived_unit = std :: unordered_map < Dim , std :: pair < rational , rational >> ; int main () { auto reduce = []( Dim d , std :: pair < rational , rational > left , std :: pair < rational , rational > right ){ using std :: min ; return U { d , { left . first + right . first , min ( left . second , right . second )}}; }; auto implies = [ = ]( derived_unit left , derived_unit right ){ derived_unit result {}; for ( auto const & A : left ) { [ & ]{ for ( auto const & B : right ) { if ( A . first == B . first ) { result . emplace_hint ( result . end (), reduce ( A . first , A . second , B . second )); right . erase ( B . first ); return ; } } result . emplace_hint ( result . end (), A ); }(); } for ( auto const & e : right ) result . insert ( e ); return result ; }; using std :: pair ; derived_unit left = { { Dim :: length , { rational ( 2 ), rational ( 1 ) } }, { Dim :: time , { rational ( - 1 ), rational ( 1 ) } }, }; derived_unit right = { { Dim :: mass , { rational ( 1 ), rational ( 1 ) } }, { Dim :: time , { rational ( - 1 ), rational ( 1 ) } }, }; auto res = implies ( left , right ); for ( auto const & e : res ) { std :: cout << boost :: format ( \"(%1%, %2%)_%3% \" ) % e . second . first % e . second . second % e . first ; } } 2nd step: Identifying the components required for type-level programming Component list for type-level programming set of basic dimensions enum class Dim { mass , time , length , //... }; The type itself is already a set. => define class and tag type member class Length { using is_dimension = void ; }; operator== for basic dimensions bool operator == ( Dim a , Dim b ) { return static_cast < std :: underlying_type_t < Dim >> ( a ) == static_cast < std :: underlying_type_t < Dim >> ( b ); } => a meta-function std::is_same type-level rational using rational = boost :: rational < std :: intmax_t > ; => std::ratio A type that can be expressed in one dimension of derived units using U = std :: pair < const Dim , std :: pair < rational , rational >> ; => define class units_t template < class BaseDimension , // base dimension tag class class Exponent , // std::ratio class Scale // std::ratio > class units_t < BaseDimension , Exponent , Scale > derived units representable type using derived_unit = std :: unordered_map < Dim , std :: pair < rational , rational >> ; unordered_map<Key, Value> is a sequence of std::pair<const Key, Value> . So we need a sequence of units_t. We can use variadic templates. => a class templates template < class ... UnitsT > struct dimensional_t { }; helper function reduce auto reduce = []( Dim d , std :: pair < rational , rational > left , std :: pair < rational , rational > right ){ using std :: min ; return U { d , { left . first + right . first , min ( left . second , right . second )} }; }; => meta-function template < class D , class Exp1 , class Exp2 , class S1 , class S2 > struct reduce < units_t < D , Exp1 , S1 > , units_t < D , Exp2 , S2 >> { using type = std :: conditional_t < std :: ratio_equal_v < std :: ratio_add < Exp1 , Exp2 > , std :: ratio < 0 >> , dimensionless < dimension_tag < D , ratio_max < Exp1 , Exp2 >>> , units_t < D , std :: ratio_add < Exp1 , Exp2 > , ratio_min < S1 , S2 >>> ; }; main loop Put spirit into recursive class template instantiation. template < class ... > struct type_list {}; template < class , class , class , class = void > struct quotient_ ; template < class SP , class Head , class ... Tail , class ... Remainders > struct quotient_ < SP , type_list < Head , Tail ... > , type_list < Remainders ... >> : std :: conditional_t < std :: is_same_v < typename SP :: dimension_type , typename Head :: dimension_type > , quotient_ < SP , type_list <> , type_list < Remainders ..., Tail ... > , typename reduce < SP , Head >:: type > , quotient_ < SP , type_list < Tail ... > , type_list < Remainders ..., Head >>> {}; template < class SP , class Inter , class ... Tail , class ... Remainders > struct quotient_ < SP , type_list < Tail ... > , type_list < Remainders ... > , Inter > { using result = type_list < Inter > ; using remainder = type_list < Tail ..., Remainders ... > ; }; template < class SP , class ... Remainders > struct quotient_ < SP , type_list <> , type_list < Remainders ... >> { using result = type_list < SP > ; using remainder = type_list < Remainders ... > ; }; template < class , class , class > struct quotient_impl ; template < class Head , class ... Tail , class ... R , class ... Results > struct quotient_impl < type_list < Head , Tail ... > , type_list < R ... > , type_list < Results ... >> : quotient_impl < type_list < Tail ... > , typename quotient_ < Head , type_list < R ... > , type_list <>>:: remainder , mitamagic :: tlist_cat_t < type_list < Results ... > , typename quotient_ < Head , type_list < R ... > , type_list <>>:: result >> {}; template < class ... R , class ... Results > struct quotient_impl < type_list <> , type_list < R ... > , type_list < Results ... >> { using result_type = dimensional_t < Results ..., R ... > ; }; // quotient facade // Quotient = Dim -> Dim -> Dim template < class , class > struct quotient ; template < class ... LeftPhantomTypes , class ... RightPhantomTypes > struct quotient < dimensional_t < LeftPhantomTypes ... > , dimensional_t < RightPhantomTypes ... >> { using type = mitamagic :: tlist_remove_if_t < is_dimensionless_type , typename mitamagic :: quotient_impl < mitamagic :: type_list < LeftPhantomTypes ... > , mitamagic :: type_list < RightPhantomTypes ... > , mitamagic :: type_list <> >:: result_type > ; }; Conclusion It's a good idea to start by identifying what you need for type-level programming through runtime programming. By using phantom-type idiom, we can distinguish one type in various ways. C++ doesn't have a convenient language extension like Haskell, so we try hard at doing linear searches by relying on types. By using variadic templates, we can handle any dimension as long as the template recursion allows .","title":"Basic Concepts"},{"location":"UserManual/basic-concepts/#basic-concepts","text":"\"It is the undefined-behavior we fear when we look upon death and darkness, nothing more.\"","title":"Basic Concepts"},{"location":"UserManual/basic-concepts/#tldr","text":"mitama::quantity_t is a class template that is represents dimensional quantity. quantity_t has units as a phantom type. It can handle rational exponents like m ^ {2/3} as a unit. In the following are the explanations of the detailed definitions, their techniques, and metaprogramming, but if you are not interested, please proceed to the next page.","title":"TL;DR"},{"location":"UserManual/basic-concepts/#representation-of-unit","text":"Basic unit of a dimension \\lambda with exponent and scale is represented as a pair of exponent e \\in \\mathbb{Q} and scale s \\in \\mathbb{Q} : U_\\lambda := (e, s)_{\\lambda} for example, m = (1, 1)_{length} \\\\ mm = (1, 1/1000)_{length} \\\\ mm^{2/3} = (2/3, 1/1000)_{length} This corresponds to units_t in Mitama.Dimensional.","title":"Representation of Unit"},{"location":"UserManual/basic-concepts/#representation-of-derived-unit","text":"Let \\Lambda is a set of basic dimensions of Derived Unit, derived units is represented as a sets of Unit over \\Lambda : D_\\Lambda := {\\{U_\\lambda\\}}_{\\lambda \\in \\Lambda} for example, N = kg \\cdot m^2 \\cdot s^{-2} = \\{ (1, 1)_{mass}, (2, 1)_{length}, (-2, 1)_{time} \\} This corresponds to dimensional_t in Mitama.Dimensional.","title":"Representation of Derived Unit"},{"location":"UserManual/basic-concepts/#type-system-of-quantity","text":"Dimensional quantity is designed as quantity_t , which is a class that represents a dimensional quantity based on ValueType that is distinguished by a phantom type dimensional_t<Units...> : template < template < class > class Synonym , class ValueType , class ... Units > class quantity_t < Synonym < dimensional_t < Units ... >> , ValueType > Synonym is a phantom template template for aliasing. And each type of Units... is designed as units_t : template < class BaseDimension , // base dimension tag class class Exponent , // std::ratio class Scale // std::ratio > class units_t < BaseDimension , Exponent , Scale >","title":"Type System of Quantity"},{"location":"UserManual/basic-concepts/#tracking-units-and-conversion-factors-in-types","text":"When value a has derived unit D_\\Lambda , let that be denoted as: a: D_\\Lambda then (a:A_\\Lambda) \\pm (b:B_\\Lambda) = a \\pm b:{\\{ ( e, min(s_a, s_b) )_{\\lambda} \\ | \\ (e_a, s_a)_{\\lambda} \\in A_\\Lambda, (e_b, s_b)_{\\lambda} \\in B_\\Lambda \\}}_{\\lambda \\in \\Lambda} min (s_a, s_b) means it is automatically converted to a high precision factor. // `a` = 1 mm quantity_t < millimetre_t > a = 1 ; // `b` = 1 m quantity_t < metre_t > b = 1 ; // a + b will be millimetre a + b ; // 1001 mm (a:A_{\\Gamma}) \\times (b:B_{\\Lambda}) = a \\times b: {\\{ ( e_a + e_b, min(s_a, s_b) )_{\\sigma} \\ | \\ (e_a, s_a)_{\\sigma} \\in A_\\sigma, (e_b, s_b)_{\\sigma} \\in B_\\sigma \\}}_{\\sigma \\in \\Gamma \\cap \\Lambda } \\\\ \\cup {\\{ (e_a, s_a)_{\\gamma} \\ | \\ (e_a, s_a)_{\\gamma} \\in A_\\gamma\\}}_{\\gamma \\in \\Gamma \\backslash \\Lambda } \\\\ \\cup {\\{ (e_b, s_b)_{\\lambda} \\ | \\ (e_b, s_b)_{\\lambda} \\in B_\\lambda\\}}_{\\lambda \\in \\Lambda \\backslash \\Gamma } It is automatically converted to a high precision factor, too. (a:A_{\\Gamma}) \\div (b:B_{\\Lambda}) define {D_\\Lambda}^{-1} := {\\{ (-e, s)_{\\lambda} \\ | \\ (e, s)_{\\lambda} \\in D_\\Lambda \\}}_{\\lambda \\in \\Lambda} and (a:A_{\\Gamma}) \\div (b:B_{\\Lambda}) := (a:A_{\\Gamma}) \\times (b^{-1}:{B_{\\Lambda}}^{-1})","title":"Tracking units and conversion factors in types"},{"location":"UserManual/basic-concepts/#algorithm-of-dimension-inducing","text":"Example: [m^2 \\cdot s^{-1}] \\times [kg \\cdot s^{-1}] \\leadsto [m^2 \\cdot s^{-2} \\cdot kg] First, let mul(U_1, U_2) := (e_1 + e_2, min(s_1, s_2))_\\lambda And we consider simple dual loop: Pick a unit_t A from left. If there is a right for B with the same dimensions as A , push If there is a right for B with the same dimensions as A , push mul(A, B) to result and pop A and remove B from right, else push A to result and pop A . If left does not empty, return to 1, else push the rest of right to result Start with: left = [m^2 \\cdot s^{-1}] \\\\ right = [kg \\cdot s^{-1}] \\\\ result = [\\ ] Pick A=m^2 , and not found B. Then, we push m^2 to result and pop m^2 from left. left = [s^{-1}] \\\\ right = [kg \\cdot s^{-1}] \\\\ result = [m^2] Pick A=s^{-1} , found B=s^{-1} . Then, we push s^{-1} to result, pop s^{-1} from left, and pop s^{-1} from right. left = [\\ ] \\\\ right = [kg] \\\\ result = [m^2 \\cdot s^{-2}] Now, left is empty. So we push the rest units of right to result. left = [\\ ] \\\\ right = [\\ ] \\\\ result = [m^2 \\cdot s^{-2} \\cdot kg] Finally, we get the result [m^2 \\cdot s^{-2} \\cdot kg] -- end example","title":"Algorithm of dimension inducing"},{"location":"UserManual/basic-concepts/#dive-into-type-level-programing","text":"1st step: Implementing in runtime When you do type-level programming, do you suddenly declare classes? It's a good idea to start by identifying what you need for type-level programming through runtime programming. Well, I usually declare classes suddenly. Here is the runtime code that derives the result of the unit multiplication described in the example above: Wandbox // This file is a \"Hello, world!\" in C++ language by Clang for wandbox. #include <bits/stdc++.h> #include <boost/rational.hpp> #include <boost/format.hpp> enum class Dim { mass , time , length , //... }; bool operator == ( Dim a , Dim b ) { return static_cast < std :: underlying_type_t < Dim >> ( a ) == static_cast < std :: underlying_type_t < Dim >> ( b ); } std :: ostream & operator << ( std :: ostream & os , Dim b ) { switch ( b ) { case Dim :: time : return os << \"time\" ; case Dim :: mass : return os << \"mass\" ; case Dim :: length : return os << \"length\" ; default : return os ; } } using rational = boost :: rational < std :: intmax_t > ; using U = std :: pair < const Dim , std :: pair < rational , rational >> ; using derived_unit = std :: unordered_map < Dim , std :: pair < rational , rational >> ; int main () { auto reduce = []( Dim d , std :: pair < rational , rational > left , std :: pair < rational , rational > right ){ using std :: min ; return U { d , { left . first + right . first , min ( left . second , right . second )}}; }; auto implies = [ = ]( derived_unit left , derived_unit right ){ derived_unit result {}; for ( auto const & A : left ) { [ & ]{ for ( auto const & B : right ) { if ( A . first == B . first ) { result . emplace_hint ( result . end (), reduce ( A . first , A . second , B . second )); right . erase ( B . first ); return ; } } result . emplace_hint ( result . end (), A ); }(); } for ( auto const & e : right ) result . insert ( e ); return result ; }; using std :: pair ; derived_unit left = { { Dim :: length , { rational ( 2 ), rational ( 1 ) } }, { Dim :: time , { rational ( - 1 ), rational ( 1 ) } }, }; derived_unit right = { { Dim :: mass , { rational ( 1 ), rational ( 1 ) } }, { Dim :: time , { rational ( - 1 ), rational ( 1 ) } }, }; auto res = implies ( left , right ); for ( auto const & e : res ) { std :: cout << boost :: format ( \"(%1%, %2%)_%3% \" ) % e . second . first % e . second . second % e . first ; } } 2nd step: Identifying the components required for type-level programming Component list for type-level programming set of basic dimensions enum class Dim { mass , time , length , //... }; The type itself is already a set. => define class and tag type member class Length { using is_dimension = void ; }; operator== for basic dimensions bool operator == ( Dim a , Dim b ) { return static_cast < std :: underlying_type_t < Dim >> ( a ) == static_cast < std :: underlying_type_t < Dim >> ( b ); } => a meta-function std::is_same type-level rational using rational = boost :: rational < std :: intmax_t > ; => std::ratio A type that can be expressed in one dimension of derived units using U = std :: pair < const Dim , std :: pair < rational , rational >> ; => define class units_t template < class BaseDimension , // base dimension tag class class Exponent , // std::ratio class Scale // std::ratio > class units_t < BaseDimension , Exponent , Scale > derived units representable type using derived_unit = std :: unordered_map < Dim , std :: pair < rational , rational >> ; unordered_map<Key, Value> is a sequence of std::pair<const Key, Value> . So we need a sequence of units_t. We can use variadic templates. => a class templates template < class ... UnitsT > struct dimensional_t { }; helper function reduce auto reduce = []( Dim d , std :: pair < rational , rational > left , std :: pair < rational , rational > right ){ using std :: min ; return U { d , { left . first + right . first , min ( left . second , right . second )} }; }; => meta-function template < class D , class Exp1 , class Exp2 , class S1 , class S2 > struct reduce < units_t < D , Exp1 , S1 > , units_t < D , Exp2 , S2 >> { using type = std :: conditional_t < std :: ratio_equal_v < std :: ratio_add < Exp1 , Exp2 > , std :: ratio < 0 >> , dimensionless < dimension_tag < D , ratio_max < Exp1 , Exp2 >>> , units_t < D , std :: ratio_add < Exp1 , Exp2 > , ratio_min < S1 , S2 >>> ; }; main loop Put spirit into recursive class template instantiation. template < class ... > struct type_list {}; template < class , class , class , class = void > struct quotient_ ; template < class SP , class Head , class ... Tail , class ... Remainders > struct quotient_ < SP , type_list < Head , Tail ... > , type_list < Remainders ... >> : std :: conditional_t < std :: is_same_v < typename SP :: dimension_type , typename Head :: dimension_type > , quotient_ < SP , type_list <> , type_list < Remainders ..., Tail ... > , typename reduce < SP , Head >:: type > , quotient_ < SP , type_list < Tail ... > , type_list < Remainders ..., Head >>> {}; template < class SP , class Inter , class ... Tail , class ... Remainders > struct quotient_ < SP , type_list < Tail ... > , type_list < Remainders ... > , Inter > { using result = type_list < Inter > ; using remainder = type_list < Tail ..., Remainders ... > ; }; template < class SP , class ... Remainders > struct quotient_ < SP , type_list <> , type_list < Remainders ... >> { using result = type_list < SP > ; using remainder = type_list < Remainders ... > ; }; template < class , class , class > struct quotient_impl ; template < class Head , class ... Tail , class ... R , class ... Results > struct quotient_impl < type_list < Head , Tail ... > , type_list < R ... > , type_list < Results ... >> : quotient_impl < type_list < Tail ... > , typename quotient_ < Head , type_list < R ... > , type_list <>>:: remainder , mitamagic :: tlist_cat_t < type_list < Results ... > , typename quotient_ < Head , type_list < R ... > , type_list <>>:: result >> {}; template < class ... R , class ... Results > struct quotient_impl < type_list <> , type_list < R ... > , type_list < Results ... >> { using result_type = dimensional_t < Results ..., R ... > ; }; // quotient facade // Quotient = Dim -> Dim -> Dim template < class , class > struct quotient ; template < class ... LeftPhantomTypes , class ... RightPhantomTypes > struct quotient < dimensional_t < LeftPhantomTypes ... > , dimensional_t < RightPhantomTypes ... >> { using type = mitamagic :: tlist_remove_if_t < is_dimensionless_type , typename mitamagic :: quotient_impl < mitamagic :: type_list < LeftPhantomTypes ... > , mitamagic :: type_list < RightPhantomTypes ... > , mitamagic :: type_list <> >:: result_type > ; };","title":"Dive into type-level programing"},{"location":"UserManual/basic-concepts/#conclusion","text":"It's a good idea to start by identifying what you need for type-level programming through runtime programming. By using phantom-type idiom, we can distinguish one type in various ways. C++ doesn't have a convenient language extension like Haskell, so we try hard at doing linear searches by relying on types. By using variadic templates, we can handle any dimension as long as the template recursion allows .","title":"Conclusion"},{"location":"UserManual/delta-type/","text":"Delta type Delta type is a type to represent the difference of dimensional quantity. Typical use case is temperature difference. Assigning quantity<kelvin_t> to quantity <degree_celsius_t> will convert that value. However, delta<quantity<kelvin_t >> is a type representing temperature difference, so it is assigned without conversion. // begin example #include <dimensional/quantity.hpp> #include <dimensional/si_units/kelvin.hpp> #include <dimensional/nonsi_units/degree_celsius.hpp> #include <dimensional/delta.hpp> #include <dimensional/arithmetic.hpp> int main () { using namespace mitama ; quantity < nonsi :: degree_celsius_t > c = 100 ; // Calculated without unit conversion // because it is a temperature difference. // 20 - 10 = 10 delta kelvin <=> 10 delta degree celcius quantity < nonsi :: degree_celsius_t > res = c + delta ( ( 20 | si :: kelvins ) - ( 10 | si :: kelvins ) ); } // end example","title":"Delta type"},{"location":"UserManual/delta-type/#delta-type","text":"Delta type is a type to represent the difference of dimensional quantity. Typical use case is temperature difference. Assigning quantity<kelvin_t> to quantity <degree_celsius_t> will convert that value. However, delta<quantity<kelvin_t >> is a type representing temperature difference, so it is assigned without conversion. // begin example #include <dimensional/quantity.hpp> #include <dimensional/si_units/kelvin.hpp> #include <dimensional/nonsi_units/degree_celsius.hpp> #include <dimensional/delta.hpp> #include <dimensional/arithmetic.hpp> int main () { using namespace mitama ; quantity < nonsi :: degree_celsius_t > c = 100 ; // Calculated without unit conversion // because it is a temperature difference. // 20 - 10 = 10 delta kelvin <=> 10 delta degree celcius quantity < nonsi :: degree_celsius_t > res = c + delta ( ( 20 | si :: kelvins ) - ( 10 | si :: kelvins ) ); } // end example","title":"Delta type"},{"location":"UserManual/dimensional-quantifiers/","text":"Dimensional quantifiers \"There is both of light and dark inside C++. The important thing is to choose what we write. That's the real of C++.\" Dimensional quantifiers are defined as constexpr variables (templates) of dimensional_t. For example, inline constexpr meter_t meters ; template < std :: intmax_t N = 1 > inline constexpr powered_t < meter_t , N > meter ; If you do not specify the exponent (=1), use the plural dimension quantifiers, and if you specify it, use the singular dimension quantifiers with non-type template parameter. pipe operator overload Pipe operators are provided to attach units to values. It is allowed to convert values into quantities by piping a value to dimensional quantifiers. example // begin example #include <dimensional/quantity.hpp> #include <dimensional/si_units/all.hpp> int main () { namespace si = mitama :: si ; using mitama :: quantity_t ; // Template argument deduction for class templates quantity_t mass = 3 | si :: kilograms ; // 3 [kg] quantity_t time = 1.66 | si :: seconds ; // 1.66 [s] quantity_t volume = 4 | si :: meter < 3 > ; // 4 [m^3] } // end example multiplication and division operators Multiplication and division operators for dimensional quantifiers are provided to make derived units. // begin example #include <dimensional/quantity.hpp> #include <dimensional/si_units/all.hpp> int main () { namespace si = mitama :: si ; using mitama :: quantity_t ; // Template argument deduction for class templates quantity_t density = 3 | si :: kilograms / si :: meter < 3 > ; // 3 [kg / m^3] quantity_t speed = 1.2 | si :: meters / si :: seconds ; // 1.2 [m / s] quantity_t accel = 4 | si :: meters * si :: second <- 2 > ; // 4 [s / m^2] } // end example","title":"Dimensional quantifiers"},{"location":"UserManual/dimensional-quantifiers/#dimensional-quantifiers","text":"\"There is both of light and dark inside C++. The important thing is to choose what we write. That's the real of C++.\" Dimensional quantifiers are defined as constexpr variables (templates) of dimensional_t. For example, inline constexpr meter_t meters ; template < std :: intmax_t N = 1 > inline constexpr powered_t < meter_t , N > meter ; If you do not specify the exponent (=1), use the plural dimension quantifiers, and if you specify it, use the singular dimension quantifiers with non-type template parameter.","title":"Dimensional quantifiers"},{"location":"UserManual/dimensional-quantifiers/#pipe-operator-overload","text":"Pipe operators are provided to attach units to values. It is allowed to convert values into quantities by piping a value to dimensional quantifiers. example // begin example #include <dimensional/quantity.hpp> #include <dimensional/si_units/all.hpp> int main () { namespace si = mitama :: si ; using mitama :: quantity_t ; // Template argument deduction for class templates quantity_t mass = 3 | si :: kilograms ; // 3 [kg] quantity_t time = 1.66 | si :: seconds ; // 1.66 [s] quantity_t volume = 4 | si :: meter < 3 > ; // 4 [m^3] } // end example","title":"pipe operator overload"},{"location":"UserManual/dimensional-quantifiers/#multiplication-and-division-operators","text":"Multiplication and division operators for dimensional quantifiers are provided to make derived units. // begin example #include <dimensional/quantity.hpp> #include <dimensional/si_units/all.hpp> int main () { namespace si = mitama :: si ; using mitama :: quantity_t ; // Template argument deduction for class templates quantity_t density = 3 | si :: kilograms / si :: meter < 3 > ; // 3 [kg / m^3] quantity_t speed = 1.2 | si :: meters / si :: seconds ; // 1.2 [m / s] quantity_t accel = 4 | si :: meters * si :: second <- 2 > ; // 4 [s / m^2] } // end example","title":"multiplication and division operators"},{"location":"UserManual/dimensional-quantity-101/","text":"Dimensional quantity 101 \"Dark and difficult times lie ahead. Soon we must all face the choice between what is right and what is easy.\" \u2015 Albus Dumbledore, Harry Potter and the Goblet of Fire Unit systems There are three basic unit systems in use today: the International System of Units (SI units, from Syst\u00e8me international d'unit\u00e9s, more commonly simply called metric units) the English Engineering System of Units (commonly called English units) the British Gravitational System of Units (BG) This library only supports SI units by library default. Base units and dimensions Base units have the important property that all other units derive from them. In the SI system, there are seven such base units and corresponding physical quantities: meter (m) for length, kilogram (kg) for mass, second (s) for time, kelvin (K) for temperature, ampere (A) for electric current, candela (cd) for luminous intensity, and mole (mol) for the amount of substance. Mathematical Notation We need some suitable mathematical notation to calculate with dimensions like length, mass, time, and so forth. The dimension of length is written as [ L ], the dimension of mass as [ M ] and the dimension of time as [ T ]. The dimension of a derived unit like velocity, which is distance (length) divided by time, then becomes [ LT^{-1} ] in this notation. The dimension of force, another derived unit, is the same as the dimension of mass times acceleration, and hence the dimension of force is [ MLT^{-2} ]. Now let's think about multiplication and division of dimensional quantities. For example, a [m] \\times b [s] = c [m \\cdot s] m \\cdot s is a new unit different from both of metre and second, and can give a clear meaning that m \\cdot s is proportional to both of metre and second. And m / s is proportional to metre and inversely proportional to second. Also, m /s \\times s derives m . Dimensions of common physical quantities Many derived quantities are measured in derived units that have their own name. Force is one example: Newton (N) is a derived unit for force, equal to kg \\cdot m \\cdot s^{-2} . Another derived unit is Pascal (Pa) for pressure, i.e., force per area. The unit of Pa then equals N/m^2 or kg \\cdot m^{-1} \\cdot s^{-2} . Below are more names for derived quantities, listed with their units. Name Symbol Physical quantity Unit radian rad angle 1 hertz Hz frequency s^{-1} newton N force, weight kg \\cdot m \\cdot s^{-2} pascal Pa pressure, stress N/m^2 joule J energy, work, heat N \\times m watt W power J/s Some common physical quantities and their dimensions are listed next. Quantity Relation Unit Dimension pressure force/area N \\cdot m^{-2}=Pa [ MT^{-2}L^{-1} ] density mass/volume kg \\cdot m^{-3} [ ML^{-3} ] strain displacement/length 1 [ 1 ] Young's modulus stress/strain N \\cdot m^{-2}=Pa [ MT^{-2}L^{-1} ] Poisson's ratio transverse strain/axial strain 1 [ 1 ] moment (of force) distance \\times force N \\cdot m [ ML^2T^{-2} ] impulse force \\times time N \\cdot s [ MLT^{-1} ] linear momentum mass \\times velocity kg m \\cdot s^{-1} [ MLT^{-1} ] angular momentum distance \\times mass \\times velocity kg \\cdot m^2 \\cdot s^{-1} [ ML^2T^{-1} ] work force \\times distance N \\cdot m=J [ ML^2T^{-2} ] energy work N \\cdot m=J [ ML^2T^{-2} ] power work/time N \\cdot m \\cdot s^{-1}=W [ ML^2T^{-3} ] heat work J [ ML^2T^{-2} ] heat flux heat rate/area W \\cdot m^{-2} [ MT^{-3} ] temperature base unit K [ \\Theta ] heat capacity heat change J/K [ ML^2T^{-2}\\Theta^{-1} ] specific heat capacity heat capacity/unit mass J \\cdot K^{-1} \\cdot kg^{-1} [ L^2T^{-2}\\Theta^{-1} ] thermal conductivity heat flux/temperature gradient W \\cdot m^{-1} \\cdot K^{-1} [ MLT^{-3}\\Theta^{-1} ] dynamic viscosity shear stress/velocity gradient kg \\cdot m^{-1} \\cdot s^{-1} [ ML^{-1}T^{-1} ] kinematic viscosity dynamic viscosity/density m^2/s [ L^2T^{-1} ] surface tension energy/area J \\cdot s^{-2} [ MT^{-2} ] Metric Prefix A metric prefix is a unit prefix that precedes a basic unit of measure to indicate a multiple or fraction of the unit. Each prefix has a unique symbol that is prepended to the unit symbol. The prefix kilo- , for example, may be added to gram to indicate multiplication by one thousand; one kilogram is equal to one thousand grams. The prefix mili- , likewise, may be added to metre to indicate division by one thousand; one milimetre is equal to one thousand of a metre. The SI prefixes are standardized for use in the International System of Units (SI units). Text Symbol Factor Power yotta Y 1000000000000000000000000 10^{24} zetta Z 1000000000000000000000 10^{21} exa E 1000000000000000000 10^{18} peta P 1000000000000000 10^{15} tera T 1000000000000 10^{12} giga G 1000000000 10^9 mega M 1000000 10^6 kilo k 1000 10^3 hecto h 100 10^2 deca da 10 10^1 Text Symbol Factor Power deci d 0.1 10^{-1} centi c 0.01 10^{-2} milli m 0.001 10^{-3} micro u 0.000001 10^{-6} nano n 0.000000001 10^{-9} pico p 0.000000000001 10^{-12} femto f 0.000000000000001 10^{-15} atto a 0.000000000000000001 10^{-18} zepto z 0.000000000000000000001 10^{-21} yocto y 0.000000000000000000000001 10^{-24}","title":"Dimensional quantity 101"},{"location":"UserManual/dimensional-quantity-101/#dimensional-quantity-101","text":"\"Dark and difficult times lie ahead. Soon we must all face the choice between what is right and what is easy.\" \u2015 Albus Dumbledore, Harry Potter and the Goblet of Fire","title":"Dimensional quantity 101"},{"location":"UserManual/dimensional-quantity-101/#unit-systems","text":"There are three basic unit systems in use today: the International System of Units (SI units, from Syst\u00e8me international d'unit\u00e9s, more commonly simply called metric units) the English Engineering System of Units (commonly called English units) the British Gravitational System of Units (BG) This library only supports SI units by library default.","title":"Unit systems"},{"location":"UserManual/dimensional-quantity-101/#base-units-and-dimensions","text":"Base units have the important property that all other units derive from them. In the SI system, there are seven such base units and corresponding physical quantities: meter (m) for length, kilogram (kg) for mass, second (s) for time, kelvin (K) for temperature, ampere (A) for electric current, candela (cd) for luminous intensity, and mole (mol) for the amount of substance.","title":"Base units and dimensions"},{"location":"UserManual/dimensional-quantity-101/#mathematical-notation","text":"We need some suitable mathematical notation to calculate with dimensions like length, mass, time, and so forth. The dimension of length is written as [ L ], the dimension of mass as [ M ] and the dimension of time as [ T ]. The dimension of a derived unit like velocity, which is distance (length) divided by time, then becomes [ LT^{-1} ] in this notation. The dimension of force, another derived unit, is the same as the dimension of mass times acceleration, and hence the dimension of force is [ MLT^{-2} ]. Now let's think about multiplication and division of dimensional quantities. For example, a [m] \\times b [s] = c [m \\cdot s] m \\cdot s is a new unit different from both of metre and second, and can give a clear meaning that m \\cdot s is proportional to both of metre and second. And m / s is proportional to metre and inversely proportional to second. Also, m /s \\times s derives m .","title":"Mathematical Notation"},{"location":"UserManual/dimensional-quantity-101/#dimensions-of-common-physical-quantities","text":"Many derived quantities are measured in derived units that have their own name. Force is one example: Newton (N) is a derived unit for force, equal to kg \\cdot m \\cdot s^{-2} . Another derived unit is Pascal (Pa) for pressure, i.e., force per area. The unit of Pa then equals N/m^2 or kg \\cdot m^{-1} \\cdot s^{-2} . Below are more names for derived quantities, listed with their units. Name Symbol Physical quantity Unit radian rad angle 1 hertz Hz frequency s^{-1} newton N force, weight kg \\cdot m \\cdot s^{-2} pascal Pa pressure, stress N/m^2 joule J energy, work, heat N \\times m watt W power J/s Some common physical quantities and their dimensions are listed next. Quantity Relation Unit Dimension pressure force/area N \\cdot m^{-2}=Pa [ MT^{-2}L^{-1} ] density mass/volume kg \\cdot m^{-3} [ ML^{-3} ] strain displacement/length 1 [ 1 ] Young's modulus stress/strain N \\cdot m^{-2}=Pa [ MT^{-2}L^{-1} ] Poisson's ratio transverse strain/axial strain 1 [ 1 ] moment (of force) distance \\times force N \\cdot m [ ML^2T^{-2} ] impulse force \\times time N \\cdot s [ MLT^{-1} ] linear momentum mass \\times velocity kg m \\cdot s^{-1} [ MLT^{-1} ] angular momentum distance \\times mass \\times velocity kg \\cdot m^2 \\cdot s^{-1} [ ML^2T^{-1} ] work force \\times distance N \\cdot m=J [ ML^2T^{-2} ] energy work N \\cdot m=J [ ML^2T^{-2} ] power work/time N \\cdot m \\cdot s^{-1}=W [ ML^2T^{-3} ] heat work J [ ML^2T^{-2} ] heat flux heat rate/area W \\cdot m^{-2} [ MT^{-3} ] temperature base unit K [ \\Theta ] heat capacity heat change J/K [ ML^2T^{-2}\\Theta^{-1} ] specific heat capacity heat capacity/unit mass J \\cdot K^{-1} \\cdot kg^{-1} [ L^2T^{-2}\\Theta^{-1} ] thermal conductivity heat flux/temperature gradient W \\cdot m^{-1} \\cdot K^{-1} [ MLT^{-3}\\Theta^{-1} ] dynamic viscosity shear stress/velocity gradient kg \\cdot m^{-1} \\cdot s^{-1} [ ML^{-1}T^{-1} ] kinematic viscosity dynamic viscosity/density m^2/s [ L^2T^{-1} ] surface tension energy/area J \\cdot s^{-2} [ MT^{-2} ]","title":"Dimensions of common physical quantities"},{"location":"UserManual/dimensional-quantity-101/#metric-prefix","text":"A metric prefix is a unit prefix that precedes a basic unit of measure to indicate a multiple or fraction of the unit. Each prefix has a unique symbol that is prepended to the unit symbol. The prefix kilo- , for example, may be added to gram to indicate multiplication by one thousand; one kilogram is equal to one thousand grams. The prefix mili- , likewise, may be added to metre to indicate division by one thousand; one milimetre is equal to one thousand of a metre. The SI prefixes are standardized for use in the International System of Units (SI units). Text Symbol Factor Power yotta Y 1000000000000000000000000 10^{24} zetta Z 1000000000000000000000 10^{21} exa E 1000000000000000000 10^{18} peta P 1000000000000000 10^{15} tera T 1000000000000 10^{12} giga G 1000000000 10^9 mega M 1000000 10^6 kilo k 1000 10^3 hecto h 100 10^2 deca da 10 10^1 Text Symbol Factor Power deci d 0.1 10^{-1} centi c 0.01 10^{-2} milli m 0.001 10^{-3} micro u 0.000001 10^{-6} nano n 0.000000001 10^{-9} pico p 0.000000000001 10^{-12} femto f 0.000000000000001 10^{-15} atto a 0.000000000000000001 10^{-18} zepto z 0.000000000000000000001 10^{-21} yocto y 0.000000000000000000000001 10^{-24}","title":"Metric Prefix"},{"location":"UserManual/dimensional-refinement/","text":"Dimensional refinement \"I mean, it's sort of exciting, isn't it, breaking the rules?\" \u2014 Hermione Granger, Harry Potter and the Order of the Phoenix defined in header <dimensional/refinement.hpp> . Refinement type A function that can be guaranteed at compile time to have dimensions in accordance with the purpose while inferring units of quantity type. The following is a compilation error if the quantity (2 | meters) * (7 | meters) does not have the dimension of area L^2 completely. This code can be compiled through refinement, since m^2 is of dimension L^2 . quantity_t a1 = accepts < area_r > |= ( 2 | meters ) * ( 7 | meters ); If you want to specify the unit should be written as follows. The difference is that automatic unit conversion is performed when units are different. accepts examines only the dimensions, not the units. quantity < meter_t , int > a1 = ( 2 | meters ) * ( 7 | meters ); The following example does not compile. This is because m is the dimension of L and not L^2 . quantity_t a3 = accepts < area_r > |= ( 2 | millimeters ); // error! Partial refinement type The following is a compilation error if the quantity (2 | meters) * (2 | meters) * (2 | kilograms) / (2 | second <2>) does not partially have the dimension of mass M . The compilation passes because it actually has. quantity_t a3 = partial_accepts < sym :: M <>> |= ( 2 | meters ) * ( 2 | meters ) * ( 2 | kilograms ) / ( 2 | second < 2 > );","title":"Dimensional refinement"},{"location":"UserManual/dimensional-refinement/#dimensional-refinement","text":"\"I mean, it's sort of exciting, isn't it, breaking the rules?\" \u2014 Hermione Granger, Harry Potter and the Order of the Phoenix defined in header <dimensional/refinement.hpp> .","title":"Dimensional refinement"},{"location":"UserManual/dimensional-refinement/#refinement-type","text":"A function that can be guaranteed at compile time to have dimensions in accordance with the purpose while inferring units of quantity type. The following is a compilation error if the quantity (2 | meters) * (7 | meters) does not have the dimension of area L^2 completely. This code can be compiled through refinement, since m^2 is of dimension L^2 . quantity_t a1 = accepts < area_r > |= ( 2 | meters ) * ( 7 | meters ); If you want to specify the unit should be written as follows. The difference is that automatic unit conversion is performed when units are different. accepts examines only the dimensions, not the units. quantity < meter_t , int > a1 = ( 2 | meters ) * ( 7 | meters ); The following example does not compile. This is because m is the dimension of L and not L^2 . quantity_t a3 = accepts < area_r > |= ( 2 | millimeters ); // error!","title":"Refinement type"},{"location":"UserManual/dimensional-refinement/#partial-refinement-type","text":"The following is a compilation error if the quantity (2 | meters) * (2 | meters) * (2 | kilograms) / (2 | second <2>) does not partially have the dimension of mass M . The compilation passes because it actually has. quantity_t a3 = partial_accepts < sym :: M <>> |= ( 2 | meters ) * ( 2 | meters ) * ( 2 | kilograms ) / ( 2 | second < 2 > );","title":"Partial refinement type"},{"location":"UserManual/expression-templates/","text":"Expression templates Addition of celsius temperature and absolute temperature is possible by performing a conversion. However, there is a problem. Compiler do not know if it would be nice if the result could be adjusted to either unit. In order to solve this problem, an expression template is used. An expression template creates a temporary object and delays unit calculation until assignment. Determine how to perform unit conversion from the dimension of assignment destination. // begin example #include <dimensional/quantity.hpp> #include <dimensional/nonsi_units/degree_celsius.hpp> #include <dimensional/expr.hpp> int main (){ namespace si = mitama :: si ; namespace nonsi = mitama :: nonsi ; using mitama :: quantity , mitama :: as_expr ; quantity < decltype ( si :: kelvin <> / si :: second <> ) > x = as_expr ( 1 | si :: kelvins ) / ( 2 | si :: seconds ) + as_expr ( 2 | nonsi :: degree_celsius ) / ( 2 | si :: seconds ); // x = 137.575 [K/s] quantity < decltype ( si :: kelvin <> / si :: second <> ) > y = ( as_expr ( 11 | si :: kelvins ) - as_expr ( 1 | si :: kelvins )) / ( 2 | si :: seconds ) + ( as_expr ( 21 | nonsi :: degree_celsius ) - as_expr ( 1 | nonsi :: degree_celsius )) / ( 2 | si :: seconds ); // x = 15 [K/s] } // end example","title":"Expression templates"},{"location":"UserManual/expression-templates/#expression-templates","text":"Addition of celsius temperature and absolute temperature is possible by performing a conversion. However, there is a problem. Compiler do not know if it would be nice if the result could be adjusted to either unit. In order to solve this problem, an expression template is used. An expression template creates a temporary object and delays unit calculation until assignment. Determine how to perform unit conversion from the dimension of assignment destination. // begin example #include <dimensional/quantity.hpp> #include <dimensional/nonsi_units/degree_celsius.hpp> #include <dimensional/expr.hpp> int main (){ namespace si = mitama :: si ; namespace nonsi = mitama :: nonsi ; using mitama :: quantity , mitama :: as_expr ; quantity < decltype ( si :: kelvin <> / si :: second <> ) > x = as_expr ( 1 | si :: kelvins ) / ( 2 | si :: seconds ) + as_expr ( 2 | nonsi :: degree_celsius ) / ( 2 | si :: seconds ); // x = 137.575 [K/s] quantity < decltype ( si :: kelvin <> / si :: second <> ) > y = ( as_expr ( 11 | si :: kelvins ) - as_expr ( 1 | si :: kelvins )) / ( 2 | si :: seconds ) + ( as_expr ( 21 | nonsi :: degree_celsius ) - as_expr ( 1 | nonsi :: degree_celsius )) / ( 2 | si :: seconds ); // x = 15 [K/s] } // end example","title":"Expression templates"},{"location":"UserManual/metric-prefixes/","text":"Metric prefixes defined in header <dimensional/prefix.hpp> . Metric prefix constants for dimensional quantifiers definition namespace mitama { inline constexpr auto pico = std :: pico {}; inline constexpr auto nano = std :: nano {}; inline constexpr auto micro = std :: micro {}; inline constexpr auto milli = std :: milli {}; inline constexpr auto centi = std :: centi {}; inline constexpr auto deci = std :: deci {}; inline constexpr auto deca = std :: deca {}; inline constexpr auto hecto = std :: hecto {}; inline constexpr auto kilo = std :: kilo {}; inline constexpr auto mega = std :: mega {}; inline constexpr auto giga = std :: giga {}; inline constexpr auto tera = std :: tera {}; } Usage // begin example #include <dimensional/quantity.hpp> #include <dimensional/si_units/all.hpp> #include <dimensional/prefix.hpp> int main () { using mitama :: quantity_t ; namespace si = mitama :: si ; quantity_t a = ( 1 | mitama :: giga * si :: meters ); // 1 [Gm] } // end example","title":"Metric prefixes"},{"location":"UserManual/metric-prefixes/#metric-prefixes","text":"defined in header <dimensional/prefix.hpp> .","title":"Metric prefixes"},{"location":"UserManual/metric-prefixes/#metric-prefix-constants-for-dimensional-quantifiers","text":"definition namespace mitama { inline constexpr auto pico = std :: pico {}; inline constexpr auto nano = std :: nano {}; inline constexpr auto micro = std :: micro {}; inline constexpr auto milli = std :: milli {}; inline constexpr auto centi = std :: centi {}; inline constexpr auto deci = std :: deci {}; inline constexpr auto deca = std :: deca {}; inline constexpr auto hecto = std :: hecto {}; inline constexpr auto kilo = std :: kilo {}; inline constexpr auto mega = std :: mega {}; inline constexpr auto giga = std :: giga {}; inline constexpr auto tera = std :: tera {}; } Usage // begin example #include <dimensional/quantity.hpp> #include <dimensional/si_units/all.hpp> #include <dimensional/prefix.hpp> int main () { using mitama :: quantity_t ; namespace si = mitama :: si ; quantity_t a = ( 1 | mitama :: giga * si :: meters ); // 1 [Gm] } // end example","title":"Metric prefix constants for dimensional quantifiers"},{"location":"UserManual/mitama_quantity_t/","text":"mitama::quantity_t Defined in header <dimensional/quantity.hpp> quantity_t<Units, T> is a class that represents a dimensional quantity of Units that has value type of T . definition namespace mitama { template < class Units , // phantom type class T = double // underlying type > class quantity_t ; template < class Units , class T = double > using quantity = quantity_t < Units , T > ; } Note If the second template argument is omitted, it will be of type double . example // begin example #include <dimensional/quantity.hpp> #include <dimensional/si_units/all.hpp> int main () { namespace si = mitama :: si ; using mitama :: quantity_t ; quantity_t < si :: meter_t , int > len1 = 1 ; // 1 [m] quantity_t < si :: meter_t , double > len2 = 1.45 ; // 1.45 [m] } // end example conversions Conversion between different units is performed automatically. Conversion between units with different dimensions will result in compilation errors. // begin example #include <dimensional/quantity.hpp> #include <dimensional/si_units/all.hpp> int main () { namespace si = mitama :: si ; using mitama :: quantity_t ; quantity_t a = 3 | si :: kilograms ; quantity_t < si :: gram_t , int > b = a ; // 3000 [g] // quantity_t<si::meter_t, int> b = a; // compile error! } // end example arithmetic operators Defined in header <dimensional/arithmetic.hpp> Let q1 is a value with type of quantity_t<D1, T1> , q2 is a value with type of quantity_t<D2, T2> and v is a value with type of T3 . And arithmetic operators listed bellow are defined: expression condition q1 + q2 D1 and D2 has same dimension and std::declval<T1>() + std::declval<T2>() is valid expression q1 - q2 D1 and D2 has same dimension and std::declval<T1>() - std::declval<T2>() is valid expression q1 * q2 std::declval<T1>() * std::declval<T2>() is valid expression q1 / q2 std::declval<T1>() / std::declval<T2>() is valid expression q1 * v std::declval<T1>() * std::declval<T3>() is valid expression v * q1 std::declval<T3>() * std::declval<T1>() is valid expression q1 / v std::declval<T1>() / std::declval<T3>() is valid expression v / q1 std::declval<T3>() / std::declval<T1>() is valid expression Otherwise, arithmetic operators do not participate in overload resolution. // begin example #include <dimensional/quantity.hpp> #include <dimensional/arithmetic.hpp> #include <dimensional/si_units/all.hpp> int main () { namespace si = mitama :: si ; using mitama :: quantity_t ; quantity_t a = 4 | si :: meters ; quantity_t b = 2 | si :: meters ; a + b ; // 6 [m] a - b ; // 2 [m] a * b ; // 8 [m^2] a / b ; // 2 [dimensionless] 2 * b ; // 8 [m] b * 2 ; // 8 [m] b / 2 ; // 1 [m] 2 / b ; // 1 [m^-1] } // end example Unit conversions If unit conversion occurs, it is always converted to the higher precision. For example, meters plus millimeters convert meters to millimeters. // begin example #include <dimensional/quantity.hpp> #include <dimensional/arithmetic.hpp> #include <dimensional/si_units/all.hpp> int main () { namespace si = mitama :: si ; using mitama :: quantity_t ; quantity_t a = 4 | si :: meters ; quantity_t b = 2 | si :: millimeters ; a + b ; // 4002 [mm] a - b ; // 3998 [mm] a * b ; // 8000 [mm^2] a / b ; // 2000 [dimensionless] } // end example","title":"Quantity"},{"location":"UserManual/mitama_quantity_t/#mitamaquantity_t","text":"Defined in header <dimensional/quantity.hpp> quantity_t<Units, T> is a class that represents a dimensional quantity of Units that has value type of T . definition namespace mitama { template < class Units , // phantom type class T = double // underlying type > class quantity_t ; template < class Units , class T = double > using quantity = quantity_t < Units , T > ; } Note If the second template argument is omitted, it will be of type double . example // begin example #include <dimensional/quantity.hpp> #include <dimensional/si_units/all.hpp> int main () { namespace si = mitama :: si ; using mitama :: quantity_t ; quantity_t < si :: meter_t , int > len1 = 1 ; // 1 [m] quantity_t < si :: meter_t , double > len2 = 1.45 ; // 1.45 [m] } // end example","title":"mitama::quantity_t"},{"location":"UserManual/mitama_quantity_t/#conversions","text":"Conversion between different units is performed automatically. Conversion between units with different dimensions will result in compilation errors. // begin example #include <dimensional/quantity.hpp> #include <dimensional/si_units/all.hpp> int main () { namespace si = mitama :: si ; using mitama :: quantity_t ; quantity_t a = 3 | si :: kilograms ; quantity_t < si :: gram_t , int > b = a ; // 3000 [g] // quantity_t<si::meter_t, int> b = a; // compile error! } // end example","title":"conversions"},{"location":"UserManual/mitama_quantity_t/#arithmetic-operators","text":"Defined in header <dimensional/arithmetic.hpp> Let q1 is a value with type of quantity_t<D1, T1> , q2 is a value with type of quantity_t<D2, T2> and v is a value with type of T3 . And arithmetic operators listed bellow are defined: expression condition q1 + q2 D1 and D2 has same dimension and std::declval<T1>() + std::declval<T2>() is valid expression q1 - q2 D1 and D2 has same dimension and std::declval<T1>() - std::declval<T2>() is valid expression q1 * q2 std::declval<T1>() * std::declval<T2>() is valid expression q1 / q2 std::declval<T1>() / std::declval<T2>() is valid expression q1 * v std::declval<T1>() * std::declval<T3>() is valid expression v * q1 std::declval<T3>() * std::declval<T1>() is valid expression q1 / v std::declval<T1>() / std::declval<T3>() is valid expression v / q1 std::declval<T3>() / std::declval<T1>() is valid expression Otherwise, arithmetic operators do not participate in overload resolution. // begin example #include <dimensional/quantity.hpp> #include <dimensional/arithmetic.hpp> #include <dimensional/si_units/all.hpp> int main () { namespace si = mitama :: si ; using mitama :: quantity_t ; quantity_t a = 4 | si :: meters ; quantity_t b = 2 | si :: meters ; a + b ; // 6 [m] a - b ; // 2 [m] a * b ; // 8 [m^2] a / b ; // 2 [dimensionless] 2 * b ; // 8 [m] b * 2 ; // 8 [m] b / 2 ; // 1 [m] 2 / b ; // 1 [m^-1] } // end example","title":"arithmetic operators"},{"location":"UserManual/mitama_quantity_t/#unit-conversions","text":"If unit conversion occurs, it is always converted to the higher precision. For example, meters plus millimeters convert meters to millimeters. // begin example #include <dimensional/quantity.hpp> #include <dimensional/arithmetic.hpp> #include <dimensional/si_units/all.hpp> int main () { namespace si = mitama :: si ; using mitama :: quantity_t ; quantity_t a = 4 | si :: meters ; quantity_t b = 2 | si :: millimeters ; a + b ; // 4002 [mm] a - b ; // 3998 [mm] a * b ; // 8000 [mm^2] a / b ; // 2000 [dimensionless] } // end example","title":"Unit conversions"},{"location":"UserManual/si-derived-units/","text":"Library defined units and format Format IO std::ostream adaptor operator << is defined in header <dimensional/io.hpp> . example // begin example #include <dimensional/quantity.hpp> #include <dimensional/si_units/all.hpp> #include <dimensional/io.hpp> int main () { using mitama :: quantity_t ; namespace si = mitama :: si ; quantity_t a = 1 | si :: meters ; std :: cout << a << '\\n' ; // 1 [m] } // end example SI basic units type name quantifier name Unit symbol Quantity measured metre_t/meter_t metre/meter m length kilogram_t kilogram kg mass second_t second s time ampere_t ampere A electric current kelvin_t kelvin K temperature mole_t mole mol amount of substance candela_t candela cd luminous intensity Non SI units type name quantifier name Unit symbol Equivalents in terms of SI units hectare_t hectare ha 1\\ ha = 10^4\\ m^2 litre_t/liter_t litre/liter L 1\\ L = 10^{-3}\\ m^3 tonne_t tonne t 1\\ t = 10^3\\ kg au_t au au 1\\ au = 149,597,870,700\\ m minute_t minutes min 1\\ min = 60\\ s hour_t hours h 1\\ h = 60\\ min = 3600\\ s day_t days d 1\\ d = 24\\ h = 86400\\ s Named units derived from SI base units type name quantifier Name Symbol Quantity Equivalents SI base unit Equivalents hertz_t hertz Hz frequency 1/s s^{-1} radian_t radian rad angle m/m 1 steradian_t steradian sr solid angle m^2/m^2 1 newton_t newton N force weight kg \\cdot m/s^2 kg \\cdot m \\cdot s^{-2} pascal_t pascal Pa pressure stress N/m^2 kg \\cdot m^{-1} \\cdot s^{-2} joule_t joule J energy work heat N \\cdot m \\\\ C \\cdot V \\\\ W \\cdot s kg \\cdot m^2 \\cdot s^{-2} watt_t watt W power radiant flux J/s \\\\ V \\cdot A kg \\cdot m^2 \\cdot s^{-3} coulomb_t coulomb C electric charge quantity of electricity s \\cdot A \\\\ F \\cdot V s \\cdot A volt_t volt V voltage electrical potential difference W/A \\\\ J/C kg \\cdot m^2 \\cdot s^{-3} \\cdot A^{-1} farad_t farad F electrical capacitance C/V \\\\ s/\\Omega kg^{-1} \\cdot m^{-2} \\cdot s^4 \\cdot A^2 ohm_t ohm \\Omega electrical resistance impedance, reactance 1/S \\\\ V/A kg \\cdot m^2 \\cdot s^{-3} \\cdot A^{-2} siemens_t siemens S electrical conductance 1/\\Omega \\\\ A/V kg^{-1} \\cdot m^{-2} \\cdot s^3 \\cdot A^2 weber_t weber Wb magnetic flux J/A \\\\ T \\cdot m^2 kg \\cdot m^2 \\cdot s^{-2} \\cdot A^{-1} tesla_t tesla T magnetic induction magnetic flux density V \\cdot s/m^2 \\\\ Wb/m^2 \\\\ N/(A \\cdot m) kg \\cdot s^{-2} \\cdot A^{-1} henry_t henry H electrical inductance V \\cdot s/A \\\\ \\Omega \\cdot s \\\\ Wb/A kg \\cdot m^2 \\cdot s^{-2} \\cdot A^{-2} degree_celsius_t degree_celsius \u00b0C temperature relative to 273.15 K K K lumen_t lumen lm luminous flux cd \\cdot sr cd lux_t lux lx illuminance lm/m^2 m^{-2} \\cdot cd becquerel_t becquerel Bq radioactivity (decays per unit time) 1/s s^{-1} gray_t gray Gy absorbed dose (of ionizing radiation) J/kg m^2 \\cdot s^{-2} sievert_t sievert Sv equivalent dose (of ionizing radiation) J/kg m^2 \\cdot s^{-2} katal_t katal kat catalytic activity mol/s s^{-1} \\cdot mol Kinematic SI derived units type name quantifier Name Symbol Expression in termsof SI base units velocity_t velocity m/s m \\cdot s^{-1} acceleration_t acceleration m/s^2 m \\cdot s^{-2} jerk_t jerk m/s^3 m \\cdot s^{-3} snap_t snap m/s^4 m \\cdot s^{-4} crackle_t crackle m/s^5 m \\cdot s^{-5} pop_t pop m/s^6 m \\cdot s^{-6} angular_velocity_t angular_velocity rad/s s^{-1} angular_acceleration_t angular_acceleration rad/s^2 s^{-2} frequency_drift_t frequency_drift Hz/s s^{-2} volumetric_flow_t volumetric_flow m^3/s m^3 \\cdot s^{-1} Molar SI derived units type name quantifier Name Symbol Expression in terms of SI base units molarity_t molarity mol/m^3 m^{-3} \\cdot mol molar_volume_t molar_volume_t m^3/mol m^3 \\cdot mol^{-1} molar_entropy_t molar_entropy J/(K \\cdot mol) m^2 \\cdot kg \\cdot s^{-2} \\cdot K^{-1} \\cdot mol^{-1} molar_heat_capacity_t molar_heat_capacity J/(K \\cdot mol) m^2 \\cdot kg \\cdot s^{-2} \\cdot K^{-1} \\cdot mol^{-1} molar_energy_t molar_energy J/mol m^2 \\cdot kg \\cdot s^{-2} \\cdot mol^{-1} molar_conductivity_t molar_conductivity S \\cdot m^2/mol kg^{-1} \\cdot s^3 \\cdot A^2 \\cdot mol^{-1} molality_t molality mol/kg kg^{-1} \\cdot mol molar_mass_t molar_mass kg/mol kg \\cdot mol^{-1} catalytic_efficiency_t catalytic_efficiency m^3/(mol \\cdot s) m^3 \\cdot s^{-1} \\cdot mol^{-1} Electromagnetic SI derived units type name quantifier Name Symbol Expression in terms of SI base units electric_displacement_field_t electric_displacement_field C/m^2 m^{-2} \\cdot s \\cdot A polarization_density_t polarization_density --- m^{-2} \\cdot s \\cdot A electric_charge_density_t electric_charge_density C/m^3 m^{-3} \\cdot s \\cdot A electric_current_density_t electric_current_density A/m^2 m^{-2} \\cdot A electrical_conductivity_t electrical_conductivity S/m m^{-3} \\cdot kg^{-1} \\cdot s^3 \\cdot A^2 permittivity_t permittivity F/m m^{-3} \\cdot kg^{-1} \\cdot s^4 \\cdot A^2 permeability_t permeability H/m m \\cdot kg \\cdot s^{-2} \\cdot A^{-2} electric_field_strength_t electric_field_strength V/m m \\cdot kg \\cdot s^{-3} \\cdot A^{-1} magnetization_t magnetization A/m m^{-1} \\cdot A exposure_t exposure C/kg kg^{-1} \\cdot s \\cdot A resistivity_t resistivity \\Omega \\cdot m m^3 \\cdot kg \\cdot s^{-3} \\cdot A^{-2} linear_charge_density_t linear_charge_density C/m m^{-1} \\cdot s \\cdot A magnetic_dipole_moment_t magnetic_dipole_moment --- m^2 \\cdot A electron_mobility_t electron_mobility m^2/(V \\cdot s) kg^{-1} \\cdot s^2 \\cdot A magnetic_reluctance_t magnetic_reluctance H^{-1} m^{-2} \\cdot kg^{-1} \\cdot s^2 \\cdot A^2 magnetic_vector_potential_t magnetic_vector_potential Wb/m m \\cdot kg \\cdot s^{-2} \\cdot A^{-1} magnetic_moment_t magnetic_moment Wb \\cdot m m^3 \\cdot kg \\cdot s^{-2} \\cdot A^{-1} magnetic_rigidity_t magnetic_rigidity T \\cdot m m \\cdot kg \\cdot s^{-2} \\cdot A^{-1} magnetomotive_force_t magnetomotive_force --- A magnetic_susceptibility_t magnetic_susceptibility m/H m^{-1} \\cdot kg^{-1} \\cdot s^2 \\cdot A^2 Photometric SI derived units type name quantifier Name Symbol Expression in terms of SI base units luminous_energy_t luminous_energy lm \\cdot s s \\cdot cd \\cdot sr luminous_exposure_t luminous_energy lx \\cdot s m^{-2} \\cdot s \\cdot cd \\cdot sr luminance_t luminous_energy cd/m^2 m^{-2} \\cdot cd luminous_efficacy_t luminous_energy lm/W m^{-2} \\cdot kg^{-1} \\cdot s^3 \\cdot cd \\cdot sr Thermodynamic SI derived units type name quantifier Name Symbol Expression in terms of SI base units heat_capacity_t specific_entropy J/K m^2 \\cdot kg \\cdot s^{-2} \\cdot K^{-1} entropy_t entropy J/K m^2 \\cdot kg \\cdot s^{-2} \\cdot K^{-1} specific_heat_capacity_t specific_heat_capacity J/(K \\cdot kg) m^2 \\cdot s^{-2} \\cdot K^{-1} specific_entropy_t specific_entropy J/(K \\cdot kg) m^2 \\cdot s^{-2} \\cdot K^{-1} thermal_conductivity_t thermal_conductivity W/(m \\cdot K) m \\cdot kg \\cdot s^{-3} \\cdot K^{-1} thermal_resistance_t thermal_resistance K/W m^{-2} \\cdot kg^{-1} \\cdot s^3 \\cdot K thermal_expansion_coefficient_t thermal_expansion_coefficient K^{-1} K^{-1} temperature_gradient_t temperature_gradient K/m m^{-1} \\cdot K","title":"Library defined SI derived units and format"},{"location":"UserManual/si-derived-units/#library-defined-units-and-format","text":"","title":"Library defined units and format"},{"location":"UserManual/si-derived-units/#format-io","text":"std::ostream adaptor operator << is defined in header <dimensional/io.hpp> . example // begin example #include <dimensional/quantity.hpp> #include <dimensional/si_units/all.hpp> #include <dimensional/io.hpp> int main () { using mitama :: quantity_t ; namespace si = mitama :: si ; quantity_t a = 1 | si :: meters ; std :: cout << a << '\\n' ; // 1 [m] } // end example","title":"Format IO"},{"location":"UserManual/si-derived-units/#si-basic-units","text":"type name quantifier name Unit symbol Quantity measured metre_t/meter_t metre/meter m length kilogram_t kilogram kg mass second_t second s time ampere_t ampere A electric current kelvin_t kelvin K temperature mole_t mole mol amount of substance candela_t candela cd luminous intensity","title":"SI basic units"},{"location":"UserManual/si-derived-units/#non-si-units","text":"type name quantifier name Unit symbol Equivalents in terms of SI units hectare_t hectare ha 1\\ ha = 10^4\\ m^2 litre_t/liter_t litre/liter L 1\\ L = 10^{-3}\\ m^3 tonne_t tonne t 1\\ t = 10^3\\ kg au_t au au 1\\ au = 149,597,870,700\\ m minute_t minutes min 1\\ min = 60\\ s hour_t hours h 1\\ h = 60\\ min = 3600\\ s day_t days d 1\\ d = 24\\ h = 86400\\ s","title":"Non SI units"},{"location":"UserManual/si-derived-units/#named-units-derived-from-si-base-units","text":"type name quantifier Name Symbol Quantity Equivalents SI base unit Equivalents hertz_t hertz Hz frequency 1/s s^{-1} radian_t radian rad angle m/m 1 steradian_t steradian sr solid angle m^2/m^2 1 newton_t newton N force weight kg \\cdot m/s^2 kg \\cdot m \\cdot s^{-2} pascal_t pascal Pa pressure stress N/m^2 kg \\cdot m^{-1} \\cdot s^{-2} joule_t joule J energy work heat N \\cdot m \\\\ C \\cdot V \\\\ W \\cdot s kg \\cdot m^2 \\cdot s^{-2} watt_t watt W power radiant flux J/s \\\\ V \\cdot A kg \\cdot m^2 \\cdot s^{-3} coulomb_t coulomb C electric charge quantity of electricity s \\cdot A \\\\ F \\cdot V s \\cdot A volt_t volt V voltage electrical potential difference W/A \\\\ J/C kg \\cdot m^2 \\cdot s^{-3} \\cdot A^{-1} farad_t farad F electrical capacitance C/V \\\\ s/\\Omega kg^{-1} \\cdot m^{-2} \\cdot s^4 \\cdot A^2 ohm_t ohm \\Omega electrical resistance impedance, reactance 1/S \\\\ V/A kg \\cdot m^2 \\cdot s^{-3} \\cdot A^{-2} siemens_t siemens S electrical conductance 1/\\Omega \\\\ A/V kg^{-1} \\cdot m^{-2} \\cdot s^3 \\cdot A^2 weber_t weber Wb magnetic flux J/A \\\\ T \\cdot m^2 kg \\cdot m^2 \\cdot s^{-2} \\cdot A^{-1} tesla_t tesla T magnetic induction magnetic flux density V \\cdot s/m^2 \\\\ Wb/m^2 \\\\ N/(A \\cdot m) kg \\cdot s^{-2} \\cdot A^{-1} henry_t henry H electrical inductance V \\cdot s/A \\\\ \\Omega \\cdot s \\\\ Wb/A kg \\cdot m^2 \\cdot s^{-2} \\cdot A^{-2} degree_celsius_t degree_celsius \u00b0C temperature relative to 273.15 K K K lumen_t lumen lm luminous flux cd \\cdot sr cd lux_t lux lx illuminance lm/m^2 m^{-2} \\cdot cd becquerel_t becquerel Bq radioactivity (decays per unit time) 1/s s^{-1} gray_t gray Gy absorbed dose (of ionizing radiation) J/kg m^2 \\cdot s^{-2} sievert_t sievert Sv equivalent dose (of ionizing radiation) J/kg m^2 \\cdot s^{-2} katal_t katal kat catalytic activity mol/s s^{-1} \\cdot mol","title":"Named units derived from SI base units"},{"location":"UserManual/si-derived-units/#kinematic-si-derived-units","text":"type name quantifier Name Symbol Expression in termsof SI base units velocity_t velocity m/s m \\cdot s^{-1} acceleration_t acceleration m/s^2 m \\cdot s^{-2} jerk_t jerk m/s^3 m \\cdot s^{-3} snap_t snap m/s^4 m \\cdot s^{-4} crackle_t crackle m/s^5 m \\cdot s^{-5} pop_t pop m/s^6 m \\cdot s^{-6} angular_velocity_t angular_velocity rad/s s^{-1} angular_acceleration_t angular_acceleration rad/s^2 s^{-2} frequency_drift_t frequency_drift Hz/s s^{-2} volumetric_flow_t volumetric_flow m^3/s m^3 \\cdot s^{-1}","title":"Kinematic SI derived units"},{"location":"UserManual/si-derived-units/#molar-si-derived-units","text":"type name quantifier Name Symbol Expression in terms of SI base units molarity_t molarity mol/m^3 m^{-3} \\cdot mol molar_volume_t molar_volume_t m^3/mol m^3 \\cdot mol^{-1} molar_entropy_t molar_entropy J/(K \\cdot mol) m^2 \\cdot kg \\cdot s^{-2} \\cdot K^{-1} \\cdot mol^{-1} molar_heat_capacity_t molar_heat_capacity J/(K \\cdot mol) m^2 \\cdot kg \\cdot s^{-2} \\cdot K^{-1} \\cdot mol^{-1} molar_energy_t molar_energy J/mol m^2 \\cdot kg \\cdot s^{-2} \\cdot mol^{-1} molar_conductivity_t molar_conductivity S \\cdot m^2/mol kg^{-1} \\cdot s^3 \\cdot A^2 \\cdot mol^{-1} molality_t molality mol/kg kg^{-1} \\cdot mol molar_mass_t molar_mass kg/mol kg \\cdot mol^{-1} catalytic_efficiency_t catalytic_efficiency m^3/(mol \\cdot s) m^3 \\cdot s^{-1} \\cdot mol^{-1}","title":"Molar SI derived units"},{"location":"UserManual/si-derived-units/#electromagnetic-si-derived-units","text":"type name quantifier Name Symbol Expression in terms of SI base units electric_displacement_field_t electric_displacement_field C/m^2 m^{-2} \\cdot s \\cdot A polarization_density_t polarization_density --- m^{-2} \\cdot s \\cdot A electric_charge_density_t electric_charge_density C/m^3 m^{-3} \\cdot s \\cdot A electric_current_density_t electric_current_density A/m^2 m^{-2} \\cdot A electrical_conductivity_t electrical_conductivity S/m m^{-3} \\cdot kg^{-1} \\cdot s^3 \\cdot A^2 permittivity_t permittivity F/m m^{-3} \\cdot kg^{-1} \\cdot s^4 \\cdot A^2 permeability_t permeability H/m m \\cdot kg \\cdot s^{-2} \\cdot A^{-2} electric_field_strength_t electric_field_strength V/m m \\cdot kg \\cdot s^{-3} \\cdot A^{-1} magnetization_t magnetization A/m m^{-1} \\cdot A exposure_t exposure C/kg kg^{-1} \\cdot s \\cdot A resistivity_t resistivity \\Omega \\cdot m m^3 \\cdot kg \\cdot s^{-3} \\cdot A^{-2} linear_charge_density_t linear_charge_density C/m m^{-1} \\cdot s \\cdot A magnetic_dipole_moment_t magnetic_dipole_moment --- m^2 \\cdot A electron_mobility_t electron_mobility m^2/(V \\cdot s) kg^{-1} \\cdot s^2 \\cdot A magnetic_reluctance_t magnetic_reluctance H^{-1} m^{-2} \\cdot kg^{-1} \\cdot s^2 \\cdot A^2 magnetic_vector_potential_t magnetic_vector_potential Wb/m m \\cdot kg \\cdot s^{-2} \\cdot A^{-1} magnetic_moment_t magnetic_moment Wb \\cdot m m^3 \\cdot kg \\cdot s^{-2} \\cdot A^{-1} magnetic_rigidity_t magnetic_rigidity T \\cdot m m \\cdot kg \\cdot s^{-2} \\cdot A^{-1} magnetomotive_force_t magnetomotive_force --- A magnetic_susceptibility_t magnetic_susceptibility m/H m^{-1} \\cdot kg^{-1} \\cdot s^2 \\cdot A^2","title":"Electromagnetic SI derived units"},{"location":"UserManual/si-derived-units/#photometric-si-derived-units","text":"type name quantifier Name Symbol Expression in terms of SI base units luminous_energy_t luminous_energy lm \\cdot s s \\cdot cd \\cdot sr luminous_exposure_t luminous_energy lx \\cdot s m^{-2} \\cdot s \\cdot cd \\cdot sr luminance_t luminous_energy cd/m^2 m^{-2} \\cdot cd luminous_efficacy_t luminous_energy lm/W m^{-2} \\cdot kg^{-1} \\cdot s^3 \\cdot cd \\cdot sr","title":"Photometric SI derived units"},{"location":"UserManual/si-derived-units/#thermodynamic-si-derived-units","text":"type name quantifier Name Symbol Expression in terms of SI base units heat_capacity_t specific_entropy J/K m^2 \\cdot kg \\cdot s^{-2} \\cdot K^{-1} entropy_t entropy J/K m^2 \\cdot kg \\cdot s^{-2} \\cdot K^{-1} specific_heat_capacity_t specific_heat_capacity J/(K \\cdot kg) m^2 \\cdot s^{-2} \\cdot K^{-1} specific_entropy_t specific_entropy J/(K \\cdot kg) m^2 \\cdot s^{-2} \\cdot K^{-1} thermal_conductivity_t thermal_conductivity W/(m \\cdot K) m \\cdot kg \\cdot s^{-3} \\cdot K^{-1} thermal_resistance_t thermal_resistance K/W m^{-2} \\cdot kg^{-1} \\cdot s^3 \\cdot K thermal_expansion_coefficient_t thermal_expansion_coefficient K^{-1} K^{-1} temperature_gradient_t temperature_gradient K/m m^{-1} \\cdot K","title":"Thermodynamic SI derived units"},{"location":"UserManual/user-defined-dimension/","text":"How to define dimension class \"Fear of a C++ only increases fear of the thing itself.\" dimension type All that is required to behave as a dimension type is to define a void type alias named is_base_dimension as a type member. struct wizarding_currency { using is_base_dimension = void ; }; Base unit type Use mitama::make_unit_t to get base unit types from dimension types. using knut_t = mitama :: make_unit_t < wizarding_currency > ; Scaled unit type Use mtiama::make_unit_t to get scaled unit types from base unit types. using sickle_t = mitama :: scaled_unit_t < knut_t , std :: ratio < 29 >> ; using galleon_t = mitama :: scaled_unit_t < sickle_t , std :: ratio < 17 >> ; Dimensional quantifiers [option] inline constexpr knut_t knuts {}; inline constexpr knut_t knut {}; inline constexpr sickle_t sickles {}; inline constexpr sickle_t sickle {}; inline constexpr galleon_t galleons {}; inline constexpr galleon_t galleon {}; Format [option] Define specializations to enable formatted output. namespace mitama { template <> struct abbreviation < wizarding :: knut_t > { static constexpr char str [] = \"knuts\" ; }; template <> struct abbreviation < wizarding :: sickle_t > { static constexpr char str [] = \"sickles\" ; }; template <> struct abbreviation < wizarding :: galleon_t > { static constexpr char str [] = \"galleons\" ; }; }","title":"User define dimension"},{"location":"UserManual/user-defined-dimension/#how-to-define-dimension-class","text":"\"Fear of a C++ only increases fear of the thing itself.\"","title":"How to define dimension class"},{"location":"UserManual/user-defined-dimension/#dimension-type","text":"All that is required to behave as a dimension type is to define a void type alias named is_base_dimension as a type member. struct wizarding_currency { using is_base_dimension = void ; };","title":"dimension type"},{"location":"UserManual/user-defined-dimension/#base-unit-type","text":"Use mitama::make_unit_t to get base unit types from dimension types. using knut_t = mitama :: make_unit_t < wizarding_currency > ;","title":"Base unit type"},{"location":"UserManual/user-defined-dimension/#scaled-unit-type","text":"Use mtiama::make_unit_t to get scaled unit types from base unit types. using sickle_t = mitama :: scaled_unit_t < knut_t , std :: ratio < 29 >> ; using galleon_t = mitama :: scaled_unit_t < sickle_t , std :: ratio < 17 >> ;","title":"Scaled unit type"},{"location":"UserManual/user-defined-dimension/#dimensional-quantifiers-option","text":"inline constexpr knut_t knuts {}; inline constexpr knut_t knut {}; inline constexpr sickle_t sickles {}; inline constexpr sickle_t sickle {}; inline constexpr galleon_t galleons {}; inline constexpr galleon_t galleon {};","title":"Dimensional quantifiers [option]"},{"location":"UserManual/user-defined-dimension/#format-option","text":"Define specializations to enable formatted output. namespace mitama { template <> struct abbreviation < wizarding :: knut_t > { static constexpr char str [] = \"knuts\" ; }; template <> struct abbreviation < wizarding :: sickle_t > { static constexpr char str [] = \"sickles\" ; }; template <> struct abbreviation < wizarding :: galleon_t > { static constexpr char str [] = \"galleons\" ; }; }","title":"Format [option]"}]}