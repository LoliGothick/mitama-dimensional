{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \"Don't trust what you compile in your brain unless you know where wording of standard is.\" Motivation In real world, we treat dimensional quantities (length, mass, time, ...). And we know that addition and subtraction of quantities with different dimensions like 1 m + 2 kg do not make sense. Because we use a statically typed programming language C++, expressions that do not make sense should be ill-formed. Consequently, the natural idea of \u200b\u200bexpressing and distinguishing dimensions by types comes out. C++ Units Libraries already exist (e.g. Boost.Units). However, these libraries have the problem that the quantities that can be represent are limited to Physical Quantities . This library proposes a type system that does not limit available dimensions. In this library, it becomes possible to handle physical quantities and user defined dimensions (e.g. currency) in an integrated syntax. In addition, Mitama.Dimensional takes advantage of C++17 features/libraries and provides better syntax than the conventional Units libraries.","title":"Home"},{"location":"#introduction","text":"\"Don't trust what you compile in your brain unless you know where wording of standard is.\"","title":"Introduction"},{"location":"#motivation","text":"In real world, we treat dimensional quantities (length, mass, time, ...). And we know that addition and subtraction of quantities with different dimensions like 1 m + 2 kg do not make sense. Because we use a statically typed programming language C++, expressions that do not make sense should be ill-formed. Consequently, the natural idea of \u200b\u200bexpressing and distinguishing dimensions by types comes out. C++ Units Libraries already exist (e.g. Boost.Units). However, these libraries have the problem that the quantities that can be represent are limited to Physical Quantities . This library proposes a type system that does not limit available dimensions. In this library, it becomes possible to handle physical quantities and user defined dimensions (e.g. currency) in an integrated syntax. In addition, Mitama.Dimensional takes advantage of C++17 features/libraries and provides better syntax than the conventional Units libraries.","title":"Motivation"},{"location":"CONTRIBUTION/","text":"Contribution Guide Any contribution to Mitama.Dimensional is more than welcome! Reporting Issues The best way to contribute to this project is to send a detailed report when you encounter a problem. It is preferable to minimize the code as much as possible in problematic situations. Then include in the report the error code and environment (OS, compiler and its version, compile options) and the error message without omission. Pull request Pull requests are welcome, even if they are just a typo fix! However, any significant improvements should be related to the existing feature request or bug report. Start Clone this repository locally. Initialize submodule with command as follows: $ git sbumodule update --init --recursive The library does not depend on Boost, but the tests use Boost. Although we do not use the Boost library that needs to be built, we recommend that you install it so that CMake will automatically find it (Please refer to Boost Wiki ). The other tool you need besides the C ++ compiler to test is CMake. Please install CMake-3.1 or later which can specify C++17. Unit tests Test is located under tests directory in the repository root. There is a CMakeLists.txt file in repository root. Perform an outsource build as follows: $ mkdir build $ cd build $ cmake .. $ make -j10 $ ctest Examples If you are implementing a new feature, add sample code to examples/ . This will help us understand the changes a lot and help Mitama.Dimensional users understand your well-organized features. Documentation If you add a new feature, you will probably want to change the document. Please send PR to feature/gitbook . Of course, typo and minor wording fixes are also welcome.","title":"Contribution"},{"location":"CONTRIBUTION/#contribution-guide","text":"Any contribution to Mitama.Dimensional is more than welcome!","title":"Contribution Guide"},{"location":"CONTRIBUTION/#reporting-issues","text":"The best way to contribute to this project is to send a detailed report when you encounter a problem. It is preferable to minimize the code as much as possible in problematic situations. Then include in the report the error code and environment (OS, compiler and its version, compile options) and the error message without omission.","title":"Reporting Issues"},{"location":"CONTRIBUTION/#pull-request","text":"Pull requests are welcome, even if they are just a typo fix! However, any significant improvements should be related to the existing feature request or bug report.","title":"Pull request"},{"location":"CONTRIBUTION/#start","text":"Clone this repository locally. Initialize submodule with command as follows: $ git sbumodule update --init --recursive The library does not depend on Boost, but the tests use Boost. Although we do not use the Boost library that needs to be built, we recommend that you install it so that CMake will automatically find it (Please refer to Boost Wiki ). The other tool you need besides the C ++ compiler to test is CMake. Please install CMake-3.1 or later which can specify C++17.","title":"Start"},{"location":"CONTRIBUTION/#unit-tests","text":"Test is located under tests directory in the repository root. There is a CMakeLists.txt file in repository root. Perform an outsource build as follows: $ mkdir build $ cd build $ cmake .. $ make -j10 $ ctest","title":"Unit tests"},{"location":"CONTRIBUTION/#examples","text":"If you are implementing a new feature, add sample code to examples/ . This will help us understand the changes a lot and help Mitama.Dimensional users understand your well-organized features.","title":"Examples"},{"location":"CONTRIBUTION/#documentation","text":"If you add a new feature, you will probably want to change the document. Please send PR to feature/gitbook . Of course, typo and minor wording fixes are also welcome.","title":"Documentation"},{"location":"Reference/arithmetic/","text":"Arithmetic operators operator + operator + for quantities. Unit conversion is automatically performed. Note This operator shall not participates in overload resolution unless is_same_dimensional_v<std::decay_t<L>, std::decay_t<R>> is true is_addable_with<typename std::decay_t<L>::value_type, typename std::decay_t<R>::value_type> is true . template < class L , class R , std :: enable_if_t < std :: conjunction_v < is_same_dimensional < std :: decay_t < L > , std :: decay_t < R >> , is_addable_with < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type >> , bool > = false > constexpr auto operator + ( L && lhs , R && rhs ) { using result_type = std :: common_type_t < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type > ; return quantity_t < mitamagic :: scaled_dimension_t < typename std :: decay_t < L >:: dimension_type , typename std :: decay_t < R >:: dimension_type > , result_type > { mitamagic :: scaled_value ( std :: forward < L > ( lhs ), std :: forward < R > ( rhs ), []( auto a , auto b ){ return a + b ; }) }; } operator - operator - for quantities. Unit conversion is automatically performed. Note This operator shall not participates in overload resolution unless is_same_dimensional_v<std::decay_t<L>, std::decay_t<R>> true and is_subtractible_with<typename std::decay_t<L>::value_type, typename std::decay_t<R>::value_type> is true . template < class L , class R , std :: enable_if_t < std :: conjunction_v < is_same_dimensional < std :: decay_t < L > , std :: decay_t < R >> , is_subtractible_with < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type >> , bool > = false > constexpr auto operator - ( L && lhs , R && rhs ) { using result_type = std :: common_type_t < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type > ; return quantity_t < mitamagic :: scaled_dimension_t < typename std :: decay_t < L >:: dimension_type , typename std :: decay_t < R >:: dimension_type > , result_type > { mitamagic :: scaled_value ( std :: forward < L > ( lhs ), std :: forward < R > ( rhs ), []( auto a , auto b ){ return a - b ; }) }; } operator * (quantity, quantity) operator * for quantities. Unit conversion is automatically performed. Note This operator shall not participates in overload resolution unless is_quantity<std::decay_t<L>> is true , is_quantity<std::decay_t<R>> is true and is_multipliable_with<typename std::decay_t<L>::value_type, typename std::decay_t<R>::value_type> is true . template < class L , class R , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < L >> , is_quantity < std :: decay_t < R >> , is_multipliable_with < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type >> , bool > = false > constexpr auto operator * ( L && lhs , R && rhs ) { return quantity_t < mitamagic :: quotient_t < typename std :: decay_t < L >:: dimension_type , typename std :: decay_t < R >:: dimension_type > , std :: common_type_t < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type >> { mitamagic :: scaled_value ( std :: forward < L > ( lhs ), std :: forward < R > ( rhs ), []( auto a , auto b ){ return a * b ; }) }; } operator* (quantity, value) operator * for quantity and value. Note This operator shall not participates in overload resolution unless is_quantity<std::decay_t<L>> is true and is_multipliable<typename std::decay_t<L>::value_type> is true . template < class L , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < L >> , is_multipliable < typename std :: decay_t < L >:: value_type >> , bool > = false > constexpr auto operator * ( L && lhs , typename std :: decay_t < L >:: value_type const & rhs ) { return std :: decay_t < L > ( std :: forward < L > ( lhs ). value () * rhs ); } operator * (value, quantity) operator * for value and quantity. Note This operator shall not participates in overload resolution unless is_quantity<std::decay_t<R>> is true and is_multipliable<typename std::decay_t<R>::value_type> is true . template < class R , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < R >> , is_multipliable < typename std :: decay_t < R >:: value_type >> , bool > = false > constexpr auto operator * ( typename std :: decay_t < R >:: value_type const & lhs , R && rhs ) { return std :: decay_t < R > ( std :: forward < R > ( rhs ). value () * lhs ); } operator / (quantity, quantity) operator / for quantities. Unit conversion is automatically performed. Note This operator shall not participates in overload resolution unless is_quantity<std::decay_t<L>> is true , is_quantity<std::decay_t<R>> is true and is_dividable_with<typename std::decay_t<L>::value_type, typename std::decay_t<R>::value_type> is true . template < class L , class R , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < L >> , is_quantity < std :: decay_t < R >> , is_dividable_with < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type >> , bool > = false > constexpr auto operator / ( L && lhs , R && rhs ) { return quantity_t < mitamagic :: quotient_t < typename std :: decay_t < L >:: dimension_type , mitamagic :: inverse_t < typename std :: decay_t < R >:: dimension_type >> , std :: common_type_t < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type > > { mitamagic :: scaled_value ( std :: forward < L > ( lhs ), std :: forward < R > ( rhs ), []( auto a , auto b ){ return a / b ; }) }; } operator/ (quantity, value) operator / for quantity and value. Note This operator shall not participates in overload resolution unless is_quantity<std::decay_t<L>> is true and is_dividable<typename std::decay_t<L>::value_type> is true . template < class L , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < L >> , is_dividable < typename std :: decay_t < L >:: value_type >> , bool > = false > constexpr auto operator / ( L && lhs , typename std :: decay_t < L >:: value_type const & rhs ) { return std :: decay_t < L > ( std :: forward < L > ( lhs ). value () / rhs ); } operator / (value, quantity) operator / for value and quantity. Note This operator shall not participates in overload resolution unless is_quantity<std::decay_t<R>> is true and is_dividable<typename std::decay_t<R>::value_type> is true . template < class R , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < R >> , is_dividable < typename std :: decay_t < R >:: value_type >> , bool > = false > constexpr auto operator / ( typename std :: decay_t < R >:: value_type const & lhs , R && rhs ) { return quantity_t < si_base_units < mitamagic :: inverse_t < typename std :: decay_t < R >:: dimension_type >> , typename std :: decay_t < R >:: value_type > { lhs / std :: forward < R > ( rhs ). value () }; }","title":"arithmetic"},{"location":"Reference/arithmetic/#arithmetic-operators","text":"","title":"Arithmetic operators"},{"location":"Reference/arithmetic/#operator","text":"operator + for quantities. Unit conversion is automatically performed. Note This operator shall not participates in overload resolution unless is_same_dimensional_v<std::decay_t<L>, std::decay_t<R>> is true is_addable_with<typename std::decay_t<L>::value_type, typename std::decay_t<R>::value_type> is true . template < class L , class R , std :: enable_if_t < std :: conjunction_v < is_same_dimensional < std :: decay_t < L > , std :: decay_t < R >> , is_addable_with < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type >> , bool > = false > constexpr auto operator + ( L && lhs , R && rhs ) { using result_type = std :: common_type_t < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type > ; return quantity_t < mitamagic :: scaled_dimension_t < typename std :: decay_t < L >:: dimension_type , typename std :: decay_t < R >:: dimension_type > , result_type > { mitamagic :: scaled_value ( std :: forward < L > ( lhs ), std :: forward < R > ( rhs ), []( auto a , auto b ){ return a + b ; }) }; }","title":"operator +"},{"location":"Reference/arithmetic/#operator-","text":"operator - for quantities. Unit conversion is automatically performed. Note This operator shall not participates in overload resolution unless is_same_dimensional_v<std::decay_t<L>, std::decay_t<R>> true and is_subtractible_with<typename std::decay_t<L>::value_type, typename std::decay_t<R>::value_type> is true . template < class L , class R , std :: enable_if_t < std :: conjunction_v < is_same_dimensional < std :: decay_t < L > , std :: decay_t < R >> , is_subtractible_with < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type >> , bool > = false > constexpr auto operator - ( L && lhs , R && rhs ) { using result_type = std :: common_type_t < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type > ; return quantity_t < mitamagic :: scaled_dimension_t < typename std :: decay_t < L >:: dimension_type , typename std :: decay_t < R >:: dimension_type > , result_type > { mitamagic :: scaled_value ( std :: forward < L > ( lhs ), std :: forward < R > ( rhs ), []( auto a , auto b ){ return a - b ; }) }; }","title":"operator -"},{"location":"Reference/arithmetic/#operator-quantity-quantity","text":"operator * for quantities. Unit conversion is automatically performed. Note This operator shall not participates in overload resolution unless is_quantity<std::decay_t<L>> is true , is_quantity<std::decay_t<R>> is true and is_multipliable_with<typename std::decay_t<L>::value_type, typename std::decay_t<R>::value_type> is true . template < class L , class R , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < L >> , is_quantity < std :: decay_t < R >> , is_multipliable_with < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type >> , bool > = false > constexpr auto operator * ( L && lhs , R && rhs ) { return quantity_t < mitamagic :: quotient_t < typename std :: decay_t < L >:: dimension_type , typename std :: decay_t < R >:: dimension_type > , std :: common_type_t < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type >> { mitamagic :: scaled_value ( std :: forward < L > ( lhs ), std :: forward < R > ( rhs ), []( auto a , auto b ){ return a * b ; }) }; }","title":"operator * (quantity, quantity)"},{"location":"Reference/arithmetic/#operator-quantity-value","text":"operator * for quantity and value. Note This operator shall not participates in overload resolution unless is_quantity<std::decay_t<L>> is true and is_multipliable<typename std::decay_t<L>::value_type> is true . template < class L , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < L >> , is_multipliable < typename std :: decay_t < L >:: value_type >> , bool > = false > constexpr auto operator * ( L && lhs , typename std :: decay_t < L >:: value_type const & rhs ) { return std :: decay_t < L > ( std :: forward < L > ( lhs ). value () * rhs ); }","title":"operator* (quantity, value)"},{"location":"Reference/arithmetic/#operator-value-quantity","text":"operator * for value and quantity. Note This operator shall not participates in overload resolution unless is_quantity<std::decay_t<R>> is true and is_multipliable<typename std::decay_t<R>::value_type> is true . template < class R , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < R >> , is_multipliable < typename std :: decay_t < R >:: value_type >> , bool > = false > constexpr auto operator * ( typename std :: decay_t < R >:: value_type const & lhs , R && rhs ) { return std :: decay_t < R > ( std :: forward < R > ( rhs ). value () * lhs ); }","title":"operator * (value, quantity)"},{"location":"Reference/arithmetic/#operator-quantity-quantity_1","text":"operator / for quantities. Unit conversion is automatically performed. Note This operator shall not participates in overload resolution unless is_quantity<std::decay_t<L>> is true , is_quantity<std::decay_t<R>> is true and is_dividable_with<typename std::decay_t<L>::value_type, typename std::decay_t<R>::value_type> is true . template < class L , class R , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < L >> , is_quantity < std :: decay_t < R >> , is_dividable_with < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type >> , bool > = false > constexpr auto operator / ( L && lhs , R && rhs ) { return quantity_t < mitamagic :: quotient_t < typename std :: decay_t < L >:: dimension_type , mitamagic :: inverse_t < typename std :: decay_t < R >:: dimension_type >> , std :: common_type_t < typename std :: decay_t < L >:: value_type , typename std :: decay_t < R >:: value_type > > { mitamagic :: scaled_value ( std :: forward < L > ( lhs ), std :: forward < R > ( rhs ), []( auto a , auto b ){ return a / b ; }) }; }","title":"operator / (quantity, quantity)"},{"location":"Reference/arithmetic/#operator-quantity-value_1","text":"operator / for quantity and value. Note This operator shall not participates in overload resolution unless is_quantity<std::decay_t<L>> is true and is_dividable<typename std::decay_t<L>::value_type> is true . template < class L , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < L >> , is_dividable < typename std :: decay_t < L >:: value_type >> , bool > = false > constexpr auto operator / ( L && lhs , typename std :: decay_t < L >:: value_type const & rhs ) { return std :: decay_t < L > ( std :: forward < L > ( lhs ). value () / rhs ); }","title":"operator/ (quantity, value)"},{"location":"Reference/arithmetic/#operator-value-quantity_1","text":"operator / for value and quantity. Note This operator shall not participates in overload resolution unless is_quantity<std::decay_t<R>> is true and is_dividable<typename std::decay_t<R>::value_type> is true . template < class R , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < R >> , is_dividable < typename std :: decay_t < R >:: value_type >> , bool > = false > constexpr auto operator / ( typename std :: decay_t < R >:: value_type const & lhs , R && rhs ) { return quantity_t < si_base_units < mitamagic :: inverse_t < typename std :: decay_t < R >:: dimension_type >> , typename std :: decay_t < R >:: value_type > { lhs / std :: forward < R > ( rhs ). value () }; }","title":"operator / (value, quantity)"},{"location":"Reference/math-functions/","text":"Math functions for quantity abs.hpp abs( quantity ) Calculates absolute value of quantity. template < template < class > class Synonym , class T , class ... Units > auto abs ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: abs ; return std :: decay_t < decltype ( quantity ) > { abs ( quantity . value ()) }; } logarithm.hpp log( quantity ) Calculates log of quantity and returns dimensionless quantity. template < template < class > class Repr , class T , class ... Units > auto log ( quantity_t < Repr < dimensional_t < Units ... >> , T > const & q ) -> quantity_t < si_base_units_repr < dimensional_t <>> , T > { using std :: log ; return { std :: log ( q . value ())}; } log2( quantity ) Calculates log2 of quantity and returns dimensionless quantity. template < template < class > class Repr , class T , class ... Units > auto log2 ( quantity_t < Repr < dimensional_t < Units ... >> , T > const & q ) -> quantity_t < si_base_units_repr < dimensional_t <>> , T > { using std :: log2 ; return { log2 ( q . value ())}; } log10( quantity ) Calculates log10 of quantity and returns dimensionless quantity. template < template < class > class Repr , class T , class ... Units > auto log10 ( quantity_t < Repr < dimensional_t < Units ... >> , T > const & q ) -> quantity_t < si_base_units_repr < dimensional_t <>> , T > { using std :: log10 ; return { log10 ( q . value ())}; } log1p( quantity ) Calculates log1p of quantity and returns dimensionless quantity. template < template < class > class Repr , class T , class ... Units > auto log1p ( quantity_t < Repr < dimensional_t < Units ... >> , T > const & q ) -> quantity_t < si_base_units_repr < dimensional_t <>> , T > { using std :: log1p ; return { log1p ( q . value ())}; } minmax.hpp min( quantities... ) Calculates min of quantities. Units conversion is perform automatically. template < class First , class Second , class ... Quantities , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < First >> , is_quantity < std :: decay_t < Second >> , is_quantity < std :: decay_t < Quantities >> ... > , bool > = false > auto min ( First first , Second second , Quantities ... quantities ) -> :: mitama :: common_type_t < First , Second , Quantities ... > { using ret = :: mitama :: common_type_t < First , Second , Quantities ... > ; if constexpr ( sizeof ...( Quantities ) == 0 ) { return first < second ? static_cast < ret > ( first ) : static_cast < ret > ( second ); } else { return :: mitama :: min ( first < second ? static_cast < ret > ( first ) : static_cast < ret > ( second ), quantities ...); } } max( quantities... ) Calculates max of quantities. Units conversion is perform automatically. template < class First , class Second , class ... Quantities , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < First >> , is_quantity < std :: decay_t < Second >> , is_quantity < std :: decay_t < Quantities >> ... > , bool > = false > auto max ( First first , Second second , Quantities ... quantities ) -> :: mitama :: common_type_t < First , Second , Quantities ... > { using ret = :: mitama :: common_type_t < First , Second , Quantities ... > ; if constexpr ( sizeof ...( Quantities ) == 0 ) { return first > second ? static_cast < ret > ( first ) : static_cast < ret > ( second ); } else { return :: mitama :: max ( first > second ? static_cast < ret > ( first ) : static_cast < ret > ( second ), quantities ...); } } fdim( quantity, quantity ) Calculates fdim of quantities. Units conversion is perform automatically. template < class Q1 , class Q2 > auto fdim ( Q1 && q1 , Q2 && q2 ) -> :: mitama :: common_type_t < Q1 , Q2 > { using std :: fdim ; return :: mitama :: common_type_t < Q1 , Q2 > ( fdim ( std :: forward < Q1 > ( q1 ). value (), std :: forward < Q2 > ( q2 ). value ()) ); } modular.hpp fmod( quantity, quantity ) Calculates fdim of quantities. template < template < class > class Synonym1 , template < class > class Synonym2 , class T1 , class ... Units1 , class T2 , class ... Units2 > auto fmod ( quantity_t < Synonym1 < dimensional_t < Units1 ... >> , T1 > const & q1 , quantity_t < Synonym2 < dimensional_t < Units2 ... >> , T2 > const & q2 ) -> std :: enable_if_t < std :: is_convertible_v < T1 , long double > && std :: is_convertible_v < T2 , long double > , std :: decay_t < decltype ( q1 / q2 ) >> { using std :: fmod ; return std :: decay_t < decltype ( q1 / q2 ) > ( fmod ( q1 . value (), q2 . value ())); } fmod( quantity, value ) Calculates fmod of quantity and value. template < template < class > class Synonym , class T , class ... Units > auto fmod ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity , typename quantity_t < Synonym < dimensional_t < Units ... >> , T >:: value_type value ) { using std :: fmod ; return std :: decay_t < decltype ( quantity ) > { fmod ( quantity . value (), value ) }; } remainder( quantity, quantity ) Calculates remainder of quantities. template < template < class > class Synonym1 , template < class > class Synonym2 , class T1 , class ... Units1 , class T2 , class ... Units2 > auto remainder ( quantity_t < Synonym1 < dimensional_t < Units1 ... >> , T1 > const & q1 , quantity_t < Synonym2 < dimensional_t < Units2 ... >> , T2 > const & q2 ) -> std :: enable_if_t < std :: is_convertible_v < T1 , long double > && std :: is_convertible_v < T2 , long double > , std :: decay_t < decltype ( q1 / q2 ) >> { using std :: remainder ; return std :: decay_t < decltype ( q1 / q2 ) > ( remainder ( q1 . value (), q2 . value ())); } remainder( quantity, value ) Calculates remainder of quantity and value. template < template < class > class Synonym , class T , class ... Units > auto remainder ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity , typename quantity_t < Synonym < dimensional_t < Units ... >> , T >:: value_type value ) { using std :: remainder ; return std :: decay_t < decltype ( quantity ) > ( remainder ( quantity . value (), value )); } nearest_integer.hpp ceil( quantity ) Calculates ceil of quantity and value. template < template < class > class Synonym , class T , class ... Units > auto ceil ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: ceil ; return std :: decay_t < decltype ( quantity ) > { ceil ( quantity . value ())}; } floor( quantity ) template < template < class > class Synonym , class T , class ... Units > auto floor ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: floor ; return std :: decay_t < decltype ( quantity ) > { floor ( quantity . value ())}; } trunc( quantity ) template < template < class > class Synonym , class T , class ... Units > auto trunc ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: trunc ; return std :: decay_t < decltype ( quantity ) > { trunc ( quantity . value ())}; } round( quantity ) template < template < class > class Synonym , class T , class ... Units > auto round ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: round ; return std :: decay_t < decltype ( quantity ) > { round ( quantity . value ())}; } lround( quantity ) template < template < class > class Synonym , class T , class ... Units > auto lround ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: lround ; return quantity_t < Synonym < dimensional_t < Units ... >> , long > { lround ( quantity . value ())}; } llround( quantity ) template < template < class > class Synonym , class T , class ... Units > auto llround ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: llround ; return quantity_t < Synonym < dimensional_t < Units ... >> , long long > { llround ( quantity . value ())}; } nearbyint( quantity ) template < template < class > class Synonym , class T , class ... Units > auto nearbyint ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: nearbyint ; return std :: decay_t < decltype ( quantity ) > { nearbyint ( quantity . value ())}; } rint( quantity ) template < template < class > class Synonym , class T , class ... Units > auto rint ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: rint ; return std :: decay_t < decltype ( quantity ) > { rint ( quantity . value ())}; } lrint( quantity ) template < template < class > class Synonym , class T , class ... Units > auto lrint ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using lrint ; return quantity_t < Synonym < dimensional_t < Units ... >> , long > { lrint ( quantity . value ())}; } llrint( quantity ) template < template < class > class Synonym , class T , class ... Units > auto llrint ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: llrint ; return quantity_t < Synonym < dimensional_t < Units ... >> , long long > { llrint ( quantity . value ())}; } pow.hpp pow<N>( quantity ) template < class Exp , template < class > class Synonym , class T , class ... Units > auto pow ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: pow ; return quantity_t < Synonym < typename mitamagic :: powered_dimensional < dimensional_t < Units ... > , Exp >:: type > , T > { static_cast < T > ( pow ( quantity . value (), static_cast < long double > ( Exp :: num ) / Exp :: den )) }; } pow<std::ratio >( quantity ) template < std :: intmax_t Exp , template < class > class Synonym , class T , class ... Units > auto pow ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: pow ; return quantity_t < Synonym < typename mitamagic :: powered_dimensional < dimensional_t < Units ... > , std :: ratio < Exp >>:: type > , T > { static_cast < T > ( pow ( quantity . value (), static_cast < long double > ( Exp ))) }; } square( quantity ) template < template < class > class Synonym , class T , class ... Units > auto square ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { return quantity_t < Synonym < typename mitamagic :: powered_dimensional < dimensional_t < Units ... > , std :: ratio < 2 >>:: type > , T > { static_cast < T > ( quantity . value () * quantity . value ()) }; } cubic( quantity ) template < template < class > class Synonym , class T , class ... Units > auto cubic ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { return quantity_t < Synonym < typename mitamagic :: powered_dimensional < dimensional_t < Units ... > , std :: ratio < 3 >>:: type > , T > { static_cast < T > ( quantity . value () * quantity . value () * quantity . value ()) }; } sqrt.hpp sqrt( quantity ) template < template < class > class Synonym , class T , class ... Units > auto sqrt ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { return quantity_t < Synonym < typename mitamagic :: powered_dimensional < dimensional_t < Units ... > , std :: ratio < 1 , 2 >>:: type > , T > { static_cast < T > ( std :: sqrt ( quantity . value ())) }; } cbrt( quantity ) template < template < class > class Synonym , class T , class ... Units > auto cbrt ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { return quantity_t < Synonym < typename mitamagic :: powered_dimensional < dimensional_t < Units ... > , std :: ratio < 1 , 3 >>:: type > , T > { static_cast < T > ( std :: cbrt ( quantity . value ())) }; } hypot( radian, radian, [radian] ) -> value template < class ... Quantities , std :: enable_if_t < ( sizeof ...( Quantities ) == 2 || sizeof ...( Quantities ) == 3 ) && std :: conjunction_v <:: mitama :: is_same_dimensional < Quantities , :: mitama :: quantity < systems :: si :: meter_t >> ... > , bool > = false > auto hypot ( Quantities ... quantities ) { return :: mitama :: common_type_t < std :: decay_t < Quantities > ... > { std :: hypot ( static_cast <:: mitama :: common_type_t < std :: decay_t < Quantities > ... >> ( quantities ). value ()...) }; } trigonometric sin( radian ) -> value template < class T > auto sin ( quantity < systems :: si :: radian_t , T > const & rad ) { return std :: sin ( rad . value ()); } cos( radian ) -> value template < class T > auto cos ( quantity < systems :: si :: radian_t , T > const & rad ) { return std :: cos ( rad . value ()); } tan( radian ) -> value template < class T > auto tan ( quantity < systems :: si :: radian_t , T > const & rad ) { return std :: tan ( rad . value ()); } asin( value ) -> radian template < class T , std :: enable_if_t <! is_quantity_v < T > , bool > = false > auto asin ( T const & v ) { return std :: asin ( v ) | systems :: si :: radian ; } acos( value ) -> radian template < class T , std :: enable_if_t <! is_quantity_v < T > , bool > = false > auto acos ( T const & v ) { return std :: acos ( v ) | systems :: si :: radian ; } atan( value ) -> radian template < class T , std :: enable_if_t <! is_quantity_v < T > , bool > = false > auto atan ( T const & v ) { return std :: atan ( v ) | systems :: si :: radian ; }","title":"math functions"},{"location":"Reference/math-functions/#math-functions-for-quantity","text":"","title":"Math functions for quantity"},{"location":"Reference/math-functions/#abshpp","text":"","title":"abs.hpp"},{"location":"Reference/math-functions/#abs-quantity","text":"Calculates absolute value of quantity. template < template < class > class Synonym , class T , class ... Units > auto abs ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: abs ; return std :: decay_t < decltype ( quantity ) > { abs ( quantity . value ()) }; }","title":"abs( quantity )"},{"location":"Reference/math-functions/#logarithmhpp","text":"","title":"logarithm.hpp"},{"location":"Reference/math-functions/#log-quantity","text":"Calculates log of quantity and returns dimensionless quantity. template < template < class > class Repr , class T , class ... Units > auto log ( quantity_t < Repr < dimensional_t < Units ... >> , T > const & q ) -> quantity_t < si_base_units_repr < dimensional_t <>> , T > { using std :: log ; return { std :: log ( q . value ())}; }","title":"log( quantity )"},{"location":"Reference/math-functions/#log2-quantity","text":"Calculates log2 of quantity and returns dimensionless quantity. template < template < class > class Repr , class T , class ... Units > auto log2 ( quantity_t < Repr < dimensional_t < Units ... >> , T > const & q ) -> quantity_t < si_base_units_repr < dimensional_t <>> , T > { using std :: log2 ; return { log2 ( q . value ())}; }","title":"log2( quantity )"},{"location":"Reference/math-functions/#log10-quantity","text":"Calculates log10 of quantity and returns dimensionless quantity. template < template < class > class Repr , class T , class ... Units > auto log10 ( quantity_t < Repr < dimensional_t < Units ... >> , T > const & q ) -> quantity_t < si_base_units_repr < dimensional_t <>> , T > { using std :: log10 ; return { log10 ( q . value ())}; }","title":"log10( quantity )"},{"location":"Reference/math-functions/#log1p-quantity","text":"Calculates log1p of quantity and returns dimensionless quantity. template < template < class > class Repr , class T , class ... Units > auto log1p ( quantity_t < Repr < dimensional_t < Units ... >> , T > const & q ) -> quantity_t < si_base_units_repr < dimensional_t <>> , T > { using std :: log1p ; return { log1p ( q . value ())}; }","title":"log1p( quantity )"},{"location":"Reference/math-functions/#minmaxhpp","text":"","title":"minmax.hpp"},{"location":"Reference/math-functions/#min-quantities","text":"Calculates min of quantities. Units conversion is perform automatically. template < class First , class Second , class ... Quantities , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < First >> , is_quantity < std :: decay_t < Second >> , is_quantity < std :: decay_t < Quantities >> ... > , bool > = false > auto min ( First first , Second second , Quantities ... quantities ) -> :: mitama :: common_type_t < First , Second , Quantities ... > { using ret = :: mitama :: common_type_t < First , Second , Quantities ... > ; if constexpr ( sizeof ...( Quantities ) == 0 ) { return first < second ? static_cast < ret > ( first ) : static_cast < ret > ( second ); } else { return :: mitama :: min ( first < second ? static_cast < ret > ( first ) : static_cast < ret > ( second ), quantities ...); } }","title":"min( quantities... )"},{"location":"Reference/math-functions/#max-quantities","text":"Calculates max of quantities. Units conversion is perform automatically. template < class First , class Second , class ... Quantities , std :: enable_if_t < std :: conjunction_v < is_quantity < std :: decay_t < First >> , is_quantity < std :: decay_t < Second >> , is_quantity < std :: decay_t < Quantities >> ... > , bool > = false > auto max ( First first , Second second , Quantities ... quantities ) -> :: mitama :: common_type_t < First , Second , Quantities ... > { using ret = :: mitama :: common_type_t < First , Second , Quantities ... > ; if constexpr ( sizeof ...( Quantities ) == 0 ) { return first > second ? static_cast < ret > ( first ) : static_cast < ret > ( second ); } else { return :: mitama :: max ( first > second ? static_cast < ret > ( first ) : static_cast < ret > ( second ), quantities ...); } }","title":"max( quantities... )"},{"location":"Reference/math-functions/#fdim-quantity-quantity","text":"Calculates fdim of quantities. Units conversion is perform automatically. template < class Q1 , class Q2 > auto fdim ( Q1 && q1 , Q2 && q2 ) -> :: mitama :: common_type_t < Q1 , Q2 > { using std :: fdim ; return :: mitama :: common_type_t < Q1 , Q2 > ( fdim ( std :: forward < Q1 > ( q1 ). value (), std :: forward < Q2 > ( q2 ). value ()) ); }","title":"fdim( quantity, quantity )"},{"location":"Reference/math-functions/#modularhpp","text":"","title":"modular.hpp"},{"location":"Reference/math-functions/#fmod-quantity-quantity","text":"Calculates fdim of quantities. template < template < class > class Synonym1 , template < class > class Synonym2 , class T1 , class ... Units1 , class T2 , class ... Units2 > auto fmod ( quantity_t < Synonym1 < dimensional_t < Units1 ... >> , T1 > const & q1 , quantity_t < Synonym2 < dimensional_t < Units2 ... >> , T2 > const & q2 ) -> std :: enable_if_t < std :: is_convertible_v < T1 , long double > && std :: is_convertible_v < T2 , long double > , std :: decay_t < decltype ( q1 / q2 ) >> { using std :: fmod ; return std :: decay_t < decltype ( q1 / q2 ) > ( fmod ( q1 . value (), q2 . value ())); }","title":"fmod( quantity, quantity )"},{"location":"Reference/math-functions/#fmod-quantity-value","text":"Calculates fmod of quantity and value. template < template < class > class Synonym , class T , class ... Units > auto fmod ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity , typename quantity_t < Synonym < dimensional_t < Units ... >> , T >:: value_type value ) { using std :: fmod ; return std :: decay_t < decltype ( quantity ) > { fmod ( quantity . value (), value ) }; }","title":"fmod( quantity, value )"},{"location":"Reference/math-functions/#remainder-quantity-quantity","text":"Calculates remainder of quantities. template < template < class > class Synonym1 , template < class > class Synonym2 , class T1 , class ... Units1 , class T2 , class ... Units2 > auto remainder ( quantity_t < Synonym1 < dimensional_t < Units1 ... >> , T1 > const & q1 , quantity_t < Synonym2 < dimensional_t < Units2 ... >> , T2 > const & q2 ) -> std :: enable_if_t < std :: is_convertible_v < T1 , long double > && std :: is_convertible_v < T2 , long double > , std :: decay_t < decltype ( q1 / q2 ) >> { using std :: remainder ; return std :: decay_t < decltype ( q1 / q2 ) > ( remainder ( q1 . value (), q2 . value ())); }","title":"remainder( quantity, quantity )"},{"location":"Reference/math-functions/#remainder-quantity-value","text":"Calculates remainder of quantity and value. template < template < class > class Synonym , class T , class ... Units > auto remainder ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity , typename quantity_t < Synonym < dimensional_t < Units ... >> , T >:: value_type value ) { using std :: remainder ; return std :: decay_t < decltype ( quantity ) > ( remainder ( quantity . value (), value )); }","title":"remainder( quantity, value )"},{"location":"Reference/math-functions/#nearest_integerhpp","text":"","title":"nearest_integer.hpp"},{"location":"Reference/math-functions/#ceil-quantity","text":"Calculates ceil of quantity and value. template < template < class > class Synonym , class T , class ... Units > auto ceil ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: ceil ; return std :: decay_t < decltype ( quantity ) > { ceil ( quantity . value ())}; }","title":"ceil( quantity )"},{"location":"Reference/math-functions/#floor-quantity","text":"template < template < class > class Synonym , class T , class ... Units > auto floor ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: floor ; return std :: decay_t < decltype ( quantity ) > { floor ( quantity . value ())}; }","title":"floor( quantity )"},{"location":"Reference/math-functions/#trunc-quantity","text":"template < template < class > class Synonym , class T , class ... Units > auto trunc ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: trunc ; return std :: decay_t < decltype ( quantity ) > { trunc ( quantity . value ())}; }","title":"trunc( quantity )"},{"location":"Reference/math-functions/#round-quantity","text":"template < template < class > class Synonym , class T , class ... Units > auto round ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: round ; return std :: decay_t < decltype ( quantity ) > { round ( quantity . value ())}; }","title":"round( quantity )"},{"location":"Reference/math-functions/#lround-quantity","text":"template < template < class > class Synonym , class T , class ... Units > auto lround ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: lround ; return quantity_t < Synonym < dimensional_t < Units ... >> , long > { lround ( quantity . value ())}; }","title":"lround( quantity )"},{"location":"Reference/math-functions/#llround-quantity","text":"template < template < class > class Synonym , class T , class ... Units > auto llround ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: llround ; return quantity_t < Synonym < dimensional_t < Units ... >> , long long > { llround ( quantity . value ())}; }","title":"llround( quantity )"},{"location":"Reference/math-functions/#nearbyint-quantity","text":"template < template < class > class Synonym , class T , class ... Units > auto nearbyint ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: nearbyint ; return std :: decay_t < decltype ( quantity ) > { nearbyint ( quantity . value ())}; }","title":"nearbyint( quantity )"},{"location":"Reference/math-functions/#rint-quantity","text":"template < template < class > class Synonym , class T , class ... Units > auto rint ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: rint ; return std :: decay_t < decltype ( quantity ) > { rint ( quantity . value ())}; }","title":"rint( quantity )"},{"location":"Reference/math-functions/#lrint-quantity","text":"template < template < class > class Synonym , class T , class ... Units > auto lrint ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using lrint ; return quantity_t < Synonym < dimensional_t < Units ... >> , long > { lrint ( quantity . value ())}; }","title":"lrint( quantity )"},{"location":"Reference/math-functions/#llrint-quantity","text":"template < template < class > class Synonym , class T , class ... Units > auto llrint ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: llrint ; return quantity_t < Synonym < dimensional_t < Units ... >> , long long > { llrint ( quantity . value ())}; }","title":"llrint( quantity )"},{"location":"Reference/math-functions/#powhpp","text":"","title":"pow.hpp"},{"location":"Reference/math-functions/#pown-quantity","text":"template < class Exp , template < class > class Synonym , class T , class ... Units > auto pow ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: pow ; return quantity_t < Synonym < typename mitamagic :: powered_dimensional < dimensional_t < Units ... > , Exp >:: type > , T > { static_cast < T > ( pow ( quantity . value (), static_cast < long double > ( Exp :: num ) / Exp :: den )) }; }","title":"pow&lt;N&gt;( quantity )"},{"location":"Reference/math-functions/#powstdratio-quantity","text":"template < std :: intmax_t Exp , template < class > class Synonym , class T , class ... Units > auto pow ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { using std :: pow ; return quantity_t < Synonym < typename mitamagic :: powered_dimensional < dimensional_t < Units ... > , std :: ratio < Exp >>:: type > , T > { static_cast < T > ( pow ( quantity . value (), static_cast < long double > ( Exp ))) }; }","title":"pow&lt;std::ratio&gt;( quantity )"},{"location":"Reference/math-functions/#square-quantity","text":"template < template < class > class Synonym , class T , class ... Units > auto square ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { return quantity_t < Synonym < typename mitamagic :: powered_dimensional < dimensional_t < Units ... > , std :: ratio < 2 >>:: type > , T > { static_cast < T > ( quantity . value () * quantity . value ()) }; }","title":"square( quantity )"},{"location":"Reference/math-functions/#cubic-quantity","text":"template < template < class > class Synonym , class T , class ... Units > auto cubic ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { return quantity_t < Synonym < typename mitamagic :: powered_dimensional < dimensional_t < Units ... > , std :: ratio < 3 >>:: type > , T > { static_cast < T > ( quantity . value () * quantity . value () * quantity . value ()) }; }","title":"cubic( quantity )"},{"location":"Reference/math-functions/#sqrthpp","text":"","title":"sqrt.hpp"},{"location":"Reference/math-functions/#sqrt-quantity","text":"template < template < class > class Synonym , class T , class ... Units > auto sqrt ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { return quantity_t < Synonym < typename mitamagic :: powered_dimensional < dimensional_t < Units ... > , std :: ratio < 1 , 2 >>:: type > , T > { static_cast < T > ( std :: sqrt ( quantity . value ())) }; }","title":"sqrt( quantity )"},{"location":"Reference/math-functions/#cbrt-quantity","text":"template < template < class > class Synonym , class T , class ... Units > auto cbrt ( quantity_t < Synonym < dimensional_t < Units ... >> , T > const & quantity ) { return quantity_t < Synonym < typename mitamagic :: powered_dimensional < dimensional_t < Units ... > , std :: ratio < 1 , 3 >>:: type > , T > { static_cast < T > ( std :: cbrt ( quantity . value ())) }; }","title":"cbrt( quantity )"},{"location":"Reference/math-functions/#hypot-radian-radian-radian-value","text":"template < class ... Quantities , std :: enable_if_t < ( sizeof ...( Quantities ) == 2 || sizeof ...( Quantities ) == 3 ) && std :: conjunction_v <:: mitama :: is_same_dimensional < Quantities , :: mitama :: quantity < systems :: si :: meter_t >> ... > , bool > = false > auto hypot ( Quantities ... quantities ) { return :: mitama :: common_type_t < std :: decay_t < Quantities > ... > { std :: hypot ( static_cast <:: mitama :: common_type_t < std :: decay_t < Quantities > ... >> ( quantities ). value ()...) }; }","title":"hypot( radian, radian, [radian] ) -&gt; value"},{"location":"Reference/math-functions/#trigonometric","text":"","title":"trigonometric"},{"location":"Reference/math-functions/#sin-radian-value","text":"template < class T > auto sin ( quantity < systems :: si :: radian_t , T > const & rad ) { return std :: sin ( rad . value ()); }","title":"sin( radian ) -&gt; value"},{"location":"Reference/math-functions/#cos-radian-value","text":"template < class T > auto cos ( quantity < systems :: si :: radian_t , T > const & rad ) { return std :: cos ( rad . value ()); }","title":"cos( radian ) -&gt; value"},{"location":"Reference/math-functions/#tan-radian-value","text":"template < class T > auto tan ( quantity < systems :: si :: radian_t , T > const & rad ) { return std :: tan ( rad . value ()); }","title":"tan( radian ) -&gt; value"},{"location":"Reference/math-functions/#asin-value-radian","text":"template < class T , std :: enable_if_t <! is_quantity_v < T > , bool > = false > auto asin ( T const & v ) { return std :: asin ( v ) | systems :: si :: radian ; }","title":"asin( value ) -&gt; radian"},{"location":"Reference/math-functions/#acos-value-radian","text":"template < class T , std :: enable_if_t <! is_quantity_v < T > , bool > = false > auto acos ( T const & v ) { return std :: acos ( v ) | systems :: si :: radian ; }","title":"acos( value ) -&gt; radian"},{"location":"Reference/math-functions/#atan-value-radian","text":"template < class T , std :: enable_if_t <! is_quantity_v < T > , bool > = false > auto atan ( T const & v ) { return std :: atan ( v ) | systems :: si :: radian ; }","title":"atan( value ) -&gt; radian"},{"location":"Reference/meta-functions/","text":"Meta functions struct is_quantity<T> Checks whether T is a quantity_t. Provides the member constant value that is equal to true, if T is the type quantity_t, const quantity_t, volatile quantity_t, or const volatile quantity_t. Otherwise, value is equal to false. definition template < class T > struct is_quantity : std :: false_type {}; template < class D , class T > struct is_quantity < quantity_t < D , T >> : std :: true_type {}; template < class T > inline constexpr bool is_quantity_v = is_quantity < T >:: value ; struct is_units<T> Checks whether T is a units_t . Provides the member constant value that is equal to true, if T is the type units_t , const units_t , volatile units_t , or const volatile units_t . Otherwise, value is equal to false. definition template < class > struct is_units : std :: false_type {}; template < class D , class E , class S > struct is_units < units_t < D , E , S >> : std :: true_type {}; template < class U > inline constexpr bool is_units_v = is_units < U >:: value ; struct is_dimensional<T> Checks whether T is a dimensional_t . Provides the member constant value that is equal to true, if T is the type dimensional_t , const dimensional_t , volatile dimensional_t , or const volatile dimensional_t . Otherwise, value is equal to false. definition template < class > struct is_dimensional : std :: false_type {}; template < template < class > class Synonym , class ... Units > struct is_dimensional < Synonym < dimensional_t < Units ... >>> : std :: true_type {}; template < class D > inline constexpr bool is_dimensional_v = is_dimensional < D >:: value ; struct is_same_dimensional<quantity_t , quantity_t > Checks whether quantity_t<D1, T> and quantity_t<D2, U> have same dimension. Provides the member constant value that is equal to true, if quantity_t<D1, T> and quantity_t<D2, U> have same dimension, Otherwise, value is equal to false. definition template < class , class > struct is_same_dimensional : std :: false_type {}; template < class T , class U , class ... Units1 , class ... Units2 , template < class > class Synonym1 , template < class > class Synonym2 > struct is_same_dimensional < quantity_t < Synonym1 < dimensional_t < Units1 ... >> , T > , quantity_t < Synonym2 < dimensional_t < Units2 ... >> , U >> : std :: conjunction < std :: bool_constant < sizeof ...( Units1 ) == sizeof ...( Units2 ) > , std :: is_base_of < typename Units1 :: tag , dimensional_t < Units2 ... >> ... > {}; template < class ... Units1 , class ... Units2 , template < class > class Synonym1 , template < class > class Synonym2 > struct is_same_dimensional < Synonym1 < dimensional_t < Units1 ... >> , Synonym2 < dimensional_t < Units2 ... >>> : std :: conjunction < std :: bool_constant < sizeof ...( Units1 ) == sizeof ...( Units2 ) > , std :: is_base_of < typename Units1 :: tag , dimensional_t < Units2 ... >> ... > {}; template < class ... Units1 , class ... Units2 > struct is_same_dimensional < dimensional_t < Units1 ... > , dimensional_t < Units2 ... >> : std :: conjunction < std :: bool_constant < sizeof ...( Units1 ) == sizeof ...( Units2 ) > , std :: is_base_of < typename Units1 :: tag , dimensional_t < Units2 ... >> ... > {}; template < class L , class R > inline constexpr bool is_same_dimensional_v = is_same_dimensional < L , R >:: value ; struct remove_dim_if<template <class> class Pred, quantity_t > Makes a quantity_t<E ...> consisting of the dimensions of E ... except where Pred<D_i>::value is false. Provides the member type that is quantity_t<E ...> . struct is_dimensional_quantifier<T> Checks whether T is a TT<dimensional_t<D...>> (TT is a variadic template template). Provides the member constant value that is equal to true, if T is the type TT<dimensional_t<D...>> , const TT<dimensional_t<D...>> , volatile TT<dimensional_t<D...>> , or const volatile TT<dimensional_t<D...>> . Otherwise, value is equal to false.","title":"meta functions"},{"location":"Reference/meta-functions/#meta-functions","text":"","title":"Meta functions"},{"location":"Reference/meta-functions/#struct-is_quantityt","text":"Checks whether T is a quantity_t. Provides the member constant value that is equal to true, if T is the type quantity_t, const quantity_t, volatile quantity_t, or const volatile quantity_t. Otherwise, value is equal to false. definition template < class T > struct is_quantity : std :: false_type {}; template < class D , class T > struct is_quantity < quantity_t < D , T >> : std :: true_type {}; template < class T > inline constexpr bool is_quantity_v = is_quantity < T >:: value ;","title":"struct is_quantity&lt;T&gt;"},{"location":"Reference/meta-functions/#struct-is_unitst","text":"Checks whether T is a units_t . Provides the member constant value that is equal to true, if T is the type units_t , const units_t , volatile units_t , or const volatile units_t . Otherwise, value is equal to false. definition template < class > struct is_units : std :: false_type {}; template < class D , class E , class S > struct is_units < units_t < D , E , S >> : std :: true_type {}; template < class U > inline constexpr bool is_units_v = is_units < U >:: value ;","title":"struct is_units&lt;T&gt;"},{"location":"Reference/meta-functions/#struct-is_dimensionalt","text":"Checks whether T is a dimensional_t . Provides the member constant value that is equal to true, if T is the type dimensional_t , const dimensional_t , volatile dimensional_t , or const volatile dimensional_t . Otherwise, value is equal to false. definition template < class > struct is_dimensional : std :: false_type {}; template < template < class > class Synonym , class ... Units > struct is_dimensional < Synonym < dimensional_t < Units ... >>> : std :: true_type {}; template < class D > inline constexpr bool is_dimensional_v = is_dimensional < D >:: value ;","title":"struct is_dimensional&lt;T&gt;"},{"location":"Reference/meta-functions/#struct-is_same_dimensionalquantity_t-quantity_t","text":"Checks whether quantity_t<D1, T> and quantity_t<D2, U> have same dimension. Provides the member constant value that is equal to true, if quantity_t<D1, T> and quantity_t<D2, U> have same dimension, Otherwise, value is equal to false. definition template < class , class > struct is_same_dimensional : std :: false_type {}; template < class T , class U , class ... Units1 , class ... Units2 , template < class > class Synonym1 , template < class > class Synonym2 > struct is_same_dimensional < quantity_t < Synonym1 < dimensional_t < Units1 ... >> , T > , quantity_t < Synonym2 < dimensional_t < Units2 ... >> , U >> : std :: conjunction < std :: bool_constant < sizeof ...( Units1 ) == sizeof ...( Units2 ) > , std :: is_base_of < typename Units1 :: tag , dimensional_t < Units2 ... >> ... > {}; template < class ... Units1 , class ... Units2 , template < class > class Synonym1 , template < class > class Synonym2 > struct is_same_dimensional < Synonym1 < dimensional_t < Units1 ... >> , Synonym2 < dimensional_t < Units2 ... >>> : std :: conjunction < std :: bool_constant < sizeof ...( Units1 ) == sizeof ...( Units2 ) > , std :: is_base_of < typename Units1 :: tag , dimensional_t < Units2 ... >> ... > {}; template < class ... Units1 , class ... Units2 > struct is_same_dimensional < dimensional_t < Units1 ... > , dimensional_t < Units2 ... >> : std :: conjunction < std :: bool_constant < sizeof ...( Units1 ) == sizeof ...( Units2 ) > , std :: is_base_of < typename Units1 :: tag , dimensional_t < Units2 ... >> ... > {}; template < class L , class R > inline constexpr bool is_same_dimensional_v = is_same_dimensional < L , R >:: value ;","title":"struct is_same_dimensional&lt;quantity_t, quantity_t&gt;"},{"location":"Reference/meta-functions/#struct-remove_dim_iftemplate-class-class-pred-quantity_t","text":"Makes a quantity_t<E ...> consisting of the dimensions of E ... except where Pred<D_i>::value is false. Provides the member type that is quantity_t<E ...> .","title":"struct remove_dim_if&lt;template &lt;class&gt; class Pred, quantity_t&gt;"},{"location":"Reference/meta-functions/#struct-is_dimensional_quantifiert","text":"Checks whether T is a TT<dimensional_t<D...>> (TT is a variadic template template). Provides the member constant value that is equal to true, if T is the type TT<dimensional_t<D...>> , const TT<dimensional_t<D...>> , volatile TT<dimensional_t<D...>> , or const volatile TT<dimensional_t<D...>> . Otherwise, value is equal to false.","title":"struct is_dimensional_quantifier&lt;T&gt;"},{"location":"Reference/quantity/","text":"class quantity Constructors and Destructors default constructor constexpr quantity_t () : value_ {} {} Constructors for value Initializes the contained value as if in-place-initializing with expression T(std::forward<Args>(args)...) . template < class U , std :: enable_if_t < std :: is_constructible_v < T , U > && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t ( U && u ) : value_ ( std :: forward < U > ( u )) {} template < class U , std :: enable_if_t < std :: is_constructible_v < T , U > && ! std :: is_convertible_v < U , T > , bool > = false > explicit constexpr quantity_t ( U && u ) : value_ { std :: forward < U > ( u )} {} Copy constructors for linear scale quantities Initializes the contained value from o.value , and conversion factor is calculated automatically. template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> && std :: is_constructible_v < T , U > && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t ( quantity_t < D , U > const & o ) : value_ ( mitamagic :: converted_value < quantity_t > ( o )) {} template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> && std :: is_constructible_v < T , U > && ! std :: is_convertible_v < U , T > , bool > = false > explicit constexpr quantity_t ( quantity_t < D , U > const & o ) : value_ { mitamagic :: converted_value < quantity_t > ( o )} {} Copy constructors for non-linear scale quantities Initializes contained value using converter . This constructor may shall call between absolute temperature and celsius temperature or between radian and celsius angle. template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> && std :: is_constructible_v < T , U > && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t ( quantity_t < D , U > const & o ) : value_ ( :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o )) {} template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> && std :: is_constructible_v < T , U > && ! std :: is_convertible_v < U , T > , bool > = false > explicit constexpr quantity_t ( quantity_t < D , U > const & o ) : value_ { :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o )} {} Copy assignment operator Copy initializes the contained value from o.value and conversion factor is calculated automatically. template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t & operator = ( quantity_t < D , U > const & o ) & { this -> value_ = mitamagic :: converted_value < quantity_t > ( o ); return * this ; } template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t & operator = ( quantity_t < D , U > const & o ) & { this -> value_ = :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); return * this ; } In-place constructor template < class ... Args , std :: enable_if_t < std :: is_constructible_v < T , Args && ... > , bool > = false > explicit constexpr quantity_t ( std :: in_place_t , Args && ... args ) : value_ ( std :: forward < Args > ( args )...) {} In-place constructor for initializer_list template < class U , class ... Args , std :: enable_if_t < std :: is_constructible_v < T , std :: initializer_list < U > , Args && ... > , bool > = false > constexpr explicit quantity_t ( std :: in_place_t , std :: initializer_list < U > il , Args && ... args ) : value_ ( il , std :: forward < Args > ( args )...) {} Equality and Comparisons Note This operator shall not participate in overload resolution unless is_{xxx}_comparable<T, U> is true. {xxx} denotes equal ( == ), not_equal ( != ), less ( < ), less_or_equal ( <= ), greater ( > ) or greater_or_equal ( >= ). operator == template < class D , class U , std :: enable_if_t < std :: conjunction_v < is_complete_type <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , is_equal_comparable < T , U >> , bool > = false > constexpr bool operator == ( quantity_t < D , U > const & o ) const { return this -> value_ == :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < std :: conjunction_v < is_same_dimensional < quantity_t , quantity_t < D , U >> , is_equal_comparable < T , U >> , bool > = false > constexpr bool operator == ( quantity_t < D , U > const & o ) const { return this -> value_ == mitamagic :: converted_value < quantity_t > ( o ); } operator != template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator != ( quantity_t < D , U > const & o ) const { return this -> value_ != :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator != ( quantity_t < D , U > const & o ) const { return this -> value_ != mitamagic :: converted_value < quantity_t > ( o ); } operator < template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator < ( quantity_t < D , U > const & o ) const { return this -> value_ < :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator < ( quantity_t < D , U > const & o ) const { return this -> value_ < mitamagic :: converted_value < quantity_t > ( o ); } operator <= template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator <= ( quantity_t < D , U > const & o ) const { return this -> value_ <= :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator <= ( quantity_t < D , U > const & o ) const { return this -> value_ <= mitamagic :: converted_value < quantity_t > ( o ); } operator > template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator > ( quantity_t < D , U > const & o ) const { return this -> value_ > :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator > ( quantity_t < D , U > const & o ) const { return this -> value_ > mitamagic :: converted_value < quantity_t > ( o ); } operator >= template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator >= ( quantity_t < D , U > const & o ) const { return this -> value_ >= :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator >= ( quantity_t < D , U > const & o ) const { return this -> value_ >= mitamagic :: converted_value < quantity_t > ( o ); } Unary operators unary plus (promotion) Returns the quantity of its operand and integral promotion is performed. unary minus (negation) Calculates the negative of its quantity and integral promotion is performed. Accessor value() Returns contained value. constexpr T value () const { return value_ ; } operator | for dimensional quantifier It is allowed to convert values into quantities by piping a value to dimensional quantifiers. // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/si/all.hpp> int main () { namespace si = mitama :: systems :: si ; using mitama :: quantity_t ; quantity_t mass = 3 | si :: kilograms ; // 3 [kg] // ^~~~~~~~~~ template argument deduction for class templates: since C++17 quantity_t volume = 4 | si :: meter < 3 > ; // 4 [m^3] // ^~~~~~~~~~~~ variable template: since C++14 quantity_t time = 1.66 | si :: second <> ; // 1.66 [s] // ^~~~~~~~~~|~ default template argument for variable templates: since C++17 // | // default argument is 1 (same as si::second<1>) } // end example Type synonyms quantity_for quantity_for is a type alias to make SI derived units using variadic templates. // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/si/all.hpp> int main () { namespace si = mitama :: systems :: si ; using mitama :: quantity_for ; quantity_for < int , si :: meter_ < 1 > , si :: second_ <- 1 >> speed = 2 ; // 2 [m/s] // you can also write as: quantity_t<decltype(si::meter<> / si::second<>), int> speed = 2; } // end example","title":"class quantity_t"},{"location":"Reference/quantity/#class-quantity","text":"","title":"class quantity"},{"location":"Reference/quantity/#constructors-and-destructors","text":"","title":"Constructors and Destructors"},{"location":"Reference/quantity/#default-constructor","text":"constexpr quantity_t () : value_ {} {}","title":"default constructor"},{"location":"Reference/quantity/#constructors-for-value","text":"Initializes the contained value as if in-place-initializing with expression T(std::forward<Args>(args)...) . template < class U , std :: enable_if_t < std :: is_constructible_v < T , U > && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t ( U && u ) : value_ ( std :: forward < U > ( u )) {} template < class U , std :: enable_if_t < std :: is_constructible_v < T , U > && ! std :: is_convertible_v < U , T > , bool > = false > explicit constexpr quantity_t ( U && u ) : value_ { std :: forward < U > ( u )} {}","title":"Constructors for value"},{"location":"Reference/quantity/#copy-constructors-for-linear-scale-quantities","text":"Initializes the contained value from o.value , and conversion factor is calculated automatically. template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> && std :: is_constructible_v < T , U > && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t ( quantity_t < D , U > const & o ) : value_ ( mitamagic :: converted_value < quantity_t > ( o )) {} template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> && std :: is_constructible_v < T , U > && ! std :: is_convertible_v < U , T > , bool > = false > explicit constexpr quantity_t ( quantity_t < D , U > const & o ) : value_ { mitamagic :: converted_value < quantity_t > ( o )} {}","title":"Copy constructors for linear scale quantities"},{"location":"Reference/quantity/#copy-constructors-for-non-linear-scale-quantities","text":"Initializes contained value using converter . This constructor may shall call between absolute temperature and celsius temperature or between radian and celsius angle. template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> && std :: is_constructible_v < T , U > && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t ( quantity_t < D , U > const & o ) : value_ ( :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o )) {} template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> && std :: is_constructible_v < T , U > && ! std :: is_convertible_v < U , T > , bool > = false > explicit constexpr quantity_t ( quantity_t < D , U > const & o ) : value_ { :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o )} {}","title":"Copy constructors for non-linear scale quantities"},{"location":"Reference/quantity/#copy-assignment-operator","text":"Copy initializes the contained value from o.value and conversion factor is calculated automatically. template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t & operator = ( quantity_t < D , U > const & o ) & { this -> value_ = mitamagic :: converted_value < quantity_t > ( o ); return * this ; } template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> && std :: is_convertible_v < U , T > , bool > = false > constexpr quantity_t & operator = ( quantity_t < D , U > const & o ) & { this -> value_ = :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); return * this ; }","title":"Copy assignment operator"},{"location":"Reference/quantity/#in-place-constructor","text":"template < class ... Args , std :: enable_if_t < std :: is_constructible_v < T , Args && ... > , bool > = false > explicit constexpr quantity_t ( std :: in_place_t , Args && ... args ) : value_ ( std :: forward < Args > ( args )...) {}","title":"In-place constructor"},{"location":"Reference/quantity/#in-place-constructor-for-initializer_list","text":"template < class U , class ... Args , std :: enable_if_t < std :: is_constructible_v < T , std :: initializer_list < U > , Args && ... > , bool > = false > constexpr explicit quantity_t ( std :: in_place_t , std :: initializer_list < U > il , Args && ... args ) : value_ ( il , std :: forward < Args > ( args )...) {}","title":"In-place constructor for initializer_list"},{"location":"Reference/quantity/#equality-and-comparisons","text":"Note This operator shall not participate in overload resolution unless is_{xxx}_comparable<T, U> is true. {xxx} denotes equal ( == ), not_equal ( != ), less ( < ), less_or_equal ( <= ), greater ( > ) or greater_or_equal ( >= ).","title":"Equality and Comparisons"},{"location":"Reference/quantity/#operator","text":"template < class D , class U , std :: enable_if_t < std :: conjunction_v < is_complete_type <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , is_equal_comparable < T , U >> , bool > = false > constexpr bool operator == ( quantity_t < D , U > const & o ) const { return this -> value_ == :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < std :: conjunction_v < is_same_dimensional < quantity_t , quantity_t < D , U >> , is_equal_comparable < T , U >> , bool > = false > constexpr bool operator == ( quantity_t < D , U > const & o ) const { return this -> value_ == mitamagic :: converted_value < quantity_t > ( o ); }","title":"operator =="},{"location":"Reference/quantity/#operator_1","text":"template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator != ( quantity_t < D , U > const & o ) const { return this -> value_ != :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator != ( quantity_t < D , U > const & o ) const { return this -> value_ != mitamagic :: converted_value < quantity_t > ( o ); }","title":"operator !="},{"location":"Reference/quantity/#operator_2","text":"template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator < ( quantity_t < D , U > const & o ) const { return this -> value_ < :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator < ( quantity_t < D , U > const & o ) const { return this -> value_ < mitamagic :: converted_value < quantity_t > ( o ); }","title":"operator &lt;"},{"location":"Reference/quantity/#operator_3","text":"template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator <= ( quantity_t < D , U > const & o ) const { return this -> value_ <= :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator <= ( quantity_t < D , U > const & o ) const { return this -> value_ <= mitamagic :: converted_value < quantity_t > ( o ); }","title":"operator &lt;="},{"location":"Reference/quantity/#operator_4","text":"template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator > ( quantity_t < D , U > const & o ) const { return this -> value_ > :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator > ( quantity_t < D , U > const & o ) const { return this -> value_ > mitamagic :: converted_value < quantity_t > ( o ); }","title":"operator &gt;"},{"location":"Reference/quantity/#operator_5","text":"template < class D , class U , std :: enable_if_t < is_complete_type_v <:: mitama :: converter < quantity_t < D , U > , quantity_t >> , bool > = false > constexpr bool operator >= ( quantity_t < D , U > const & o ) const { return this -> value_ >= :: mitama :: converter < quantity_t < D , U > , quantity_t >:: convert ( o ); } template < class D , class U , std :: enable_if_t < is_same_dimensional_v < quantity_t , quantity_t < D , U >> , bool > = false > constexpr bool operator >= ( quantity_t < D , U > const & o ) const { return this -> value_ >= mitamagic :: converted_value < quantity_t > ( o ); }","title":"operator &gt;="},{"location":"Reference/quantity/#unary-operators","text":"","title":"Unary operators"},{"location":"Reference/quantity/#unary-plus-promotion","text":"Returns the quantity of its operand and integral promotion is performed.","title":"unary plus (promotion)"},{"location":"Reference/quantity/#unary-minus-negation","text":"Calculates the negative of its quantity and integral promotion is performed.","title":"unary minus (negation)"},{"location":"Reference/quantity/#accessor","text":"","title":"Accessor"},{"location":"Reference/quantity/#value","text":"Returns contained value. constexpr T value () const { return value_ ; }","title":"value()"},{"location":"Reference/quantity/#operator-for-dimensional-quantifier","text":"It is allowed to convert values into quantities by piping a value to dimensional quantifiers. // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/si/all.hpp> int main () { namespace si = mitama :: systems :: si ; using mitama :: quantity_t ; quantity_t mass = 3 | si :: kilograms ; // 3 [kg] // ^~~~~~~~~~ template argument deduction for class templates: since C++17 quantity_t volume = 4 | si :: meter < 3 > ; // 4 [m^3] // ^~~~~~~~~~~~ variable template: since C++14 quantity_t time = 1.66 | si :: second <> ; // 1.66 [s] // ^~~~~~~~~~|~ default template argument for variable templates: since C++17 // | // default argument is 1 (same as si::second<1>) } // end example","title":"operator | for dimensional quantifier"},{"location":"Reference/quantity/#type-synonyms","text":"","title":"Type synonyms"},{"location":"Reference/quantity/#quantity_for","text":"quantity_for is a type alias to make SI derived units using variadic templates. // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/si/all.hpp> int main () { namespace si = mitama :: systems :: si ; using mitama :: quantity_for ; quantity_for < int , si :: meter_ < 1 > , si :: second_ <- 1 >> speed = 2 ; // 2 [m/s] // you can also write as: quantity_t<decltype(si::meter<> / si::second<>), int> speed = 2; } // end example","title":"quantity_for"},{"location":"UserManual/basic-concepts/","text":"Basic Concepts \"It is the undefined-behavior we fear when we look upon death and darkness, nothing more.\" TL;DR mitama::quantity_t is a class template that is represents dimensional quantity. quantity_t has units as a phantom type. It can handle rational exponents like m ^ {2/3} as a unit. In the following are the explanations of the detailed definitions, their techniques, and metaprogramming, but if you are not interested, please proceed to the next page. Representation of Unit Basic unit of a dimension \\lambda with exponent and scale is represented as a pair of exponent e \\in \\mathbb{Q} and scale s \\in \\mathbb{Q} : U_\\lambda := (e, s)_{\\lambda} for example, m = (1, 1)_{length} \\\\ mm = (1, 1/1000)_{length} \\\\ mm^{2/3} = (2/3, 1/1000)_{length} This corresponds to units_t in Mitama.Dimensional. Representation of Derived Unit Let \\Lambda is a set of basic dimensions of Derived Unit, derived units is represented as a sets of Unit over \\Lambda : D_\\Lambda := {\\{U_\\lambda\\}}_{\\lambda \\in \\Lambda} for example, N = kg \\cdot m^2 \\cdot s^{-2} = \\{ (1, 1)_{mass}, (2, 1)_{length}, (-2, 1)_{time} \\} This corresponds to dimensional_t in Mitama.Dimensional. Type System of Quantity Dimensional quantity is designed as quantity_t , which is a class that represents a dimensional quantity based on ValueType that is distinguished by a phantom type dimensional_t<Units...> : template < template < class > class Synonym , class ValueType , class ... Units > class quantity_t < Synonym < dimensional_t < Units ... >> , ValueType > Synonym is a phantom template template for aliasing. And each type of Units... is designed as units_t : template < class BaseDimension , // base dimension tag class class Exponent , // std::ratio class Scale // std::ratio > class units_t < BaseDimension , Exponent , Scale > Tracking units and conversion factors in types When value a has derived unit D_\\Lambda , let that be denoted as: a: D_\\Lambda then (a:A_\\Lambda) \\pm (b:B_\\Lambda) = a \\pm b:{\\{ ( e, min(s_a, s_b) )_{\\lambda} \\ | \\ (e_a, s_a)_{\\lambda} \\in A_\\Lambda, (e_b, s_b)_{\\lambda} \\in B_\\Lambda \\}}_{\\lambda \\in \\Lambda} min (s_a, s_b) means it is automatically converted to a high precision factor. // `a` = 1 mm quantity_t < millimetre_t > a = 1 ; // `b` = 1 m quantity_t < metre_t > b = 1 ; // a + b will be millimetre a + b ; // 1001 mm (a:A_{\\Gamma}) \\times (b:B_{\\Lambda}) = a \\times b: {\\{ ( e_a + e_b, min(s_a, s_b) )_{\\sigma} \\ | \\ (e_a, s_a)_{\\sigma} \\in A_\\sigma, (e_b, s_b)_{\\sigma} \\in B_\\sigma \\}}_{\\sigma \\in \\Gamma \\cap \\Lambda } \\\\ \\cup {\\{ (e_a, s_a)_{\\gamma} \\ | \\ (e_a, s_a)_{\\gamma} \\in A_\\gamma\\}}_{\\gamma \\in \\Gamma \\backslash \\Lambda } \\\\ \\cup {\\{ (e_b, s_b)_{\\lambda} \\ | \\ (e_b, s_b)_{\\lambda} \\in B_\\lambda\\}}_{\\lambda \\in \\Lambda \\backslash \\Gamma } It is automatically converted to a high precision factor, too. (a:A_{\\Gamma}) \\div (b:B_{\\Lambda}) define {D_\\Lambda}^{-1} := {\\{ (-e, s)_{\\lambda} \\ | \\ (e, s)_{\\lambda} \\in D_\\Lambda \\}}_{\\lambda \\in \\Lambda} and (a:A_{\\Gamma}) \\div (b:B_{\\Lambda}) := (a:A_{\\Gamma}) \\times (b^{-1}:{B_{\\Lambda}}^{-1}) Algorithm of dimension inducing Example: [m^2 \\cdot s^{-1}] \\times [kg \\cdot s^{-1}] \\leadsto [m^2 \\cdot s^{-2} \\cdot kg] First, let mul(U_1, U_2) := (e_1 + e_2, min(s_1, s_2))_\\lambda And we consider simple dual loop: Pick a unit_t A from left. If there is a right for B with the same dimensions as A , push If there is a right for B with the same dimensions as A , push mul(A, B) to result and pop A and remove B from right, else push A to result and pop A . If left does not empty, return to 1, else push the rest of right to result Start with: left = [m^2 \\cdot s^{-1}] \\\\ right = [kg \\cdot s^{-1}] \\\\ result = [\\ ] Pick A=m^2 , and not found B. Then, we push m^2 to result and pop m^2 from left. left = [s^{-1}] \\\\ right = [kg \\cdot s^{-1}] \\\\ result = [m^2] Pick A=s^{-1} , found B=s^{-1} . Then, we push s^{-1} to result, pop s^{-1} from left, and pop s^{-1} from right. left = [\\ ] \\\\ right = [kg] \\\\ result = [m^2 \\cdot s^{-2}] Now, left is empty. So we push the rest units of right to result. left = [\\ ] \\\\ right = [\\ ] \\\\ result = [m^2 \\cdot s^{-2} \\cdot kg] Finally, we get the result [m^2 \\cdot s^{-2} \\cdot kg] -- end example Dive into type-level programing 1st step: Implementing in runtime When you do type-level programming, do you suddenly declare classes? It's a good idea to start by identifying what you need for type-level programming through runtime programming. Well, I usually declare classes suddenly. Here is the runtime code that derives the result of the unit multiplication described in the example above: Wandbox // This file is a \"Hello, world!\" in C++ language by Clang for wandbox. #include <bits/stdc++.h> #include <boost/rational.hpp> #include <boost/format.hpp> enum class Dim { mass , time , length , //... }; bool operator == ( Dim a , Dim b ) { return static_cast < std :: underlying_type_t < Dim >> ( a ) == static_cast < std :: underlying_type_t < Dim >> ( b ); } std :: ostream & operator << ( std :: ostream & os , Dim b ) { switch ( b ) { case Dim :: time : return os << \"time\" ; case Dim :: mass : return os << \"mass\" ; case Dim :: length : return os << \"length\" ; default : return os ; } } using rational = boost :: rational < std :: intmax_t > ; using U = std :: pair < const Dim , std :: pair < rational , rational >> ; using derived_unit = std :: unordered_map < Dim , std :: pair < rational , rational >> ; int main () { auto reduce = []( Dim d , std :: pair < rational , rational > left , std :: pair < rational , rational > right ){ using std :: min ; return U { d , { left . first + right . first , min ( left . second , right . second )}}; }; auto implies = [ = ]( derived_unit left , derived_unit right ){ derived_unit result {}; for ( auto const & A : left ) { [ & ]{ for ( auto const & B : right ) { if ( A . first == B . first ) { result . emplace_hint ( result . end (), reduce ( A . first , A . second , B . second )); right . erase ( B . first ); return ; } } result . emplace_hint ( result . end (), A ); }(); } for ( auto const & e : right ) result . insert ( e ); return result ; }; using std :: pair ; derived_unit left = { { Dim :: length , { rational ( 2 ), rational ( 1 ) } }, { Dim :: time , { rational ( - 1 ), rational ( 1 ) } }, }; derived_unit right = { { Dim :: mass , { rational ( 1 ), rational ( 1 ) } }, { Dim :: time , { rational ( - 1 ), rational ( 1 ) } }, }; auto res = implies ( left , right ); for ( auto const & e : res ) { std :: cout << boost :: format ( \"(%1%, %2%)_%3% \" ) % e . second . first % e . second . second % e . first ; } } 2nd step: Identifying the components required for type-level programming Component list for type-level programming set of basic dimensions enum class Dim { mass , time , length , //... }; The type itself is already a set. => define class and tag type member class Length { using is_dimension = void ; }; operator== for basic dimensions bool operator == ( Dim a , Dim b ) { return static_cast < std :: underlying_type_t < Dim >> ( a ) == static_cast < std :: underlying_type_t < Dim >> ( b ); } => a meta-function std::is_same type-level rational using rational = boost :: rational < std :: intmax_t > ; => std::ratio A type that can be expressed in one dimension of derived units using U = std :: pair < const Dim , std :: pair < rational , rational >> ; => define class units_t template < class BaseDimension , // base dimension tag class class Exponent , // std::ratio class Scale // std::ratio > class units_t < BaseDimension , Exponent , Scale > derived units representable type using derived_unit = std :: unordered_map < Dim , std :: pair < rational , rational >> ; unordered_map<Key, Value> is a sequence of std::pair<const Key, Value> . So we need a sequence of units_t. We can use variadic templates. => a class templates template < class ... UnitsT > struct dimensional_t { }; helper function reduce auto reduce = []( Dim d , std :: pair < rational , rational > left , std :: pair < rational , rational > right ){ using std :: min ; return U { d , { left . first + right . first , min ( left . second , right . second )} }; }; => meta-function template < class D , class Exp1 , class Exp2 , class S1 , class S2 > struct reduce < units_t < D , Exp1 , S1 > , units_t < D , Exp2 , S2 >> { using type = std :: conditional_t < std :: ratio_equal_v < std :: ratio_add < Exp1 , Exp2 > , std :: ratio < 0 >> , dimensionless < dimension_tag < D , ratio_max < Exp1 , Exp2 >>> , units_t < D , std :: ratio_add < Exp1 , Exp2 > , ratio_min < S1 , S2 >>> ; }; main loop Put spirit into recursive class template instantiation. template < class ... > struct type_list {}; template < class , class , class , class = void > struct quotient_ ; template < class SP , class Head , class ... Tail , class ... Remainders > struct quotient_ < SP , type_list < Head , Tail ... > , type_list < Remainders ... >> : std :: conditional_t < std :: is_same_v < typename SP :: dimension_type , typename Head :: dimension_type > , quotient_ < SP , type_list <> , type_list < Remainders ..., Tail ... > , typename reduce < SP , Head >:: type > , quotient_ < SP , type_list < Tail ... > , type_list < Remainders ..., Head >>> {}; template < class SP , class Inter , class ... Tail , class ... Remainders > struct quotient_ < SP , type_list < Tail ... > , type_list < Remainders ... > , Inter > { using result = type_list < Inter > ; using remainder = type_list < Tail ..., Remainders ... > ; }; template < class SP , class ... Remainders > struct quotient_ < SP , type_list <> , type_list < Remainders ... >> { using result = type_list < SP > ; using remainder = type_list < Remainders ... > ; }; template < class , class , class > struct quotient_impl ; template < class Head , class ... Tail , class ... R , class ... Results > struct quotient_impl < type_list < Head , Tail ... > , type_list < R ... > , type_list < Results ... >> : quotient_impl < type_list < Tail ... > , typename quotient_ < Head , type_list < R ... > , type_list <>>:: remainder , mitamagic :: tlist_cat_t < type_list < Results ... > , typename quotient_ < Head , type_list < R ... > , type_list <>>:: result >> {}; template < class ... R , class ... Results > struct quotient_impl < type_list <> , type_list < R ... > , type_list < Results ... >> { using result_type = dimensional_t < Results ..., R ... > ; }; // quotient facade // Quotient = Dim -> Dim -> Dim template < class , class > struct quotient ; template < class ... LeftPhantomTypes , class ... RightPhantomTypes > struct quotient < dimensional_t < LeftPhantomTypes ... > , dimensional_t < RightPhantomTypes ... >> { using type = mitamagic :: tlist_remove_if_t < is_dimensionless_type , typename mitamagic :: quotient_impl < mitamagic :: type_list < LeftPhantomTypes ... > , mitamagic :: type_list < RightPhantomTypes ... > , mitamagic :: type_list <> >:: result_type > ; }; Conclusion It's a good idea to start by identifying what you need for type-level programming through runtime programming. By using phantom-type idiom, we can distinguish one type in various ways. C++ doesn't have a convenient language extension like Haskell, so we try hard at doing linear searches by relying on types. By using variadic templates, we can handle any dimension as long as the template recursion allows .","title":"Basic Concepts"},{"location":"UserManual/basic-concepts/#basic-concepts","text":"\"It is the undefined-behavior we fear when we look upon death and darkness, nothing more.\"","title":"Basic Concepts"},{"location":"UserManual/basic-concepts/#tldr","text":"mitama::quantity_t is a class template that is represents dimensional quantity. quantity_t has units as a phantom type. It can handle rational exponents like m ^ {2/3} as a unit. In the following are the explanations of the detailed definitions, their techniques, and metaprogramming, but if you are not interested, please proceed to the next page.","title":"TL;DR"},{"location":"UserManual/basic-concepts/#representation-of-unit","text":"Basic unit of a dimension \\lambda with exponent and scale is represented as a pair of exponent e \\in \\mathbb{Q} and scale s \\in \\mathbb{Q} : U_\\lambda := (e, s)_{\\lambda} for example, m = (1, 1)_{length} \\\\ mm = (1, 1/1000)_{length} \\\\ mm^{2/3} = (2/3, 1/1000)_{length} This corresponds to units_t in Mitama.Dimensional.","title":"Representation of Unit"},{"location":"UserManual/basic-concepts/#representation-of-derived-unit","text":"Let \\Lambda is a set of basic dimensions of Derived Unit, derived units is represented as a sets of Unit over \\Lambda : D_\\Lambda := {\\{U_\\lambda\\}}_{\\lambda \\in \\Lambda} for example, N = kg \\cdot m^2 \\cdot s^{-2} = \\{ (1, 1)_{mass}, (2, 1)_{length}, (-2, 1)_{time} \\} This corresponds to dimensional_t in Mitama.Dimensional.","title":"Representation of Derived Unit"},{"location":"UserManual/basic-concepts/#type-system-of-quantity","text":"Dimensional quantity is designed as quantity_t , which is a class that represents a dimensional quantity based on ValueType that is distinguished by a phantom type dimensional_t<Units...> : template < template < class > class Synonym , class ValueType , class ... Units > class quantity_t < Synonym < dimensional_t < Units ... >> , ValueType > Synonym is a phantom template template for aliasing. And each type of Units... is designed as units_t : template < class BaseDimension , // base dimension tag class class Exponent , // std::ratio class Scale // std::ratio > class units_t < BaseDimension , Exponent , Scale >","title":"Type System of Quantity"},{"location":"UserManual/basic-concepts/#tracking-units-and-conversion-factors-in-types","text":"When value a has derived unit D_\\Lambda , let that be denoted as: a: D_\\Lambda then (a:A_\\Lambda) \\pm (b:B_\\Lambda) = a \\pm b:{\\{ ( e, min(s_a, s_b) )_{\\lambda} \\ | \\ (e_a, s_a)_{\\lambda} \\in A_\\Lambda, (e_b, s_b)_{\\lambda} \\in B_\\Lambda \\}}_{\\lambda \\in \\Lambda} min (s_a, s_b) means it is automatically converted to a high precision factor. // `a` = 1 mm quantity_t < millimetre_t > a = 1 ; // `b` = 1 m quantity_t < metre_t > b = 1 ; // a + b will be millimetre a + b ; // 1001 mm (a:A_{\\Gamma}) \\times (b:B_{\\Lambda}) = a \\times b: {\\{ ( e_a + e_b, min(s_a, s_b) )_{\\sigma} \\ | \\ (e_a, s_a)_{\\sigma} \\in A_\\sigma, (e_b, s_b)_{\\sigma} \\in B_\\sigma \\}}_{\\sigma \\in \\Gamma \\cap \\Lambda } \\\\ \\cup {\\{ (e_a, s_a)_{\\gamma} \\ | \\ (e_a, s_a)_{\\gamma} \\in A_\\gamma\\}}_{\\gamma \\in \\Gamma \\backslash \\Lambda } \\\\ \\cup {\\{ (e_b, s_b)_{\\lambda} \\ | \\ (e_b, s_b)_{\\lambda} \\in B_\\lambda\\}}_{\\lambda \\in \\Lambda \\backslash \\Gamma } It is automatically converted to a high precision factor, too. (a:A_{\\Gamma}) \\div (b:B_{\\Lambda}) define {D_\\Lambda}^{-1} := {\\{ (-e, s)_{\\lambda} \\ | \\ (e, s)_{\\lambda} \\in D_\\Lambda \\}}_{\\lambda \\in \\Lambda} and (a:A_{\\Gamma}) \\div (b:B_{\\Lambda}) := (a:A_{\\Gamma}) \\times (b^{-1}:{B_{\\Lambda}}^{-1})","title":"Tracking units and conversion factors in types"},{"location":"UserManual/basic-concepts/#algorithm-of-dimension-inducing","text":"Example: [m^2 \\cdot s^{-1}] \\times [kg \\cdot s^{-1}] \\leadsto [m^2 \\cdot s^{-2} \\cdot kg] First, let mul(U_1, U_2) := (e_1 + e_2, min(s_1, s_2))_\\lambda And we consider simple dual loop: Pick a unit_t A from left. If there is a right for B with the same dimensions as A , push If there is a right for B with the same dimensions as A , push mul(A, B) to result and pop A and remove B from right, else push A to result and pop A . If left does not empty, return to 1, else push the rest of right to result Start with: left = [m^2 \\cdot s^{-1}] \\\\ right = [kg \\cdot s^{-1}] \\\\ result = [\\ ] Pick A=m^2 , and not found B. Then, we push m^2 to result and pop m^2 from left. left = [s^{-1}] \\\\ right = [kg \\cdot s^{-1}] \\\\ result = [m^2] Pick A=s^{-1} , found B=s^{-1} . Then, we push s^{-1} to result, pop s^{-1} from left, and pop s^{-1} from right. left = [\\ ] \\\\ right = [kg] \\\\ result = [m^2 \\cdot s^{-2}] Now, left is empty. So we push the rest units of right to result. left = [\\ ] \\\\ right = [\\ ] \\\\ result = [m^2 \\cdot s^{-2} \\cdot kg] Finally, we get the result [m^2 \\cdot s^{-2} \\cdot kg] -- end example","title":"Algorithm of dimension inducing"},{"location":"UserManual/basic-concepts/#dive-into-type-level-programing","text":"1st step: Implementing in runtime When you do type-level programming, do you suddenly declare classes? It's a good idea to start by identifying what you need for type-level programming through runtime programming. Well, I usually declare classes suddenly. Here is the runtime code that derives the result of the unit multiplication described in the example above: Wandbox // This file is a \"Hello, world!\" in C++ language by Clang for wandbox. #include <bits/stdc++.h> #include <boost/rational.hpp> #include <boost/format.hpp> enum class Dim { mass , time , length , //... }; bool operator == ( Dim a , Dim b ) { return static_cast < std :: underlying_type_t < Dim >> ( a ) == static_cast < std :: underlying_type_t < Dim >> ( b ); } std :: ostream & operator << ( std :: ostream & os , Dim b ) { switch ( b ) { case Dim :: time : return os << \"time\" ; case Dim :: mass : return os << \"mass\" ; case Dim :: length : return os << \"length\" ; default : return os ; } } using rational = boost :: rational < std :: intmax_t > ; using U = std :: pair < const Dim , std :: pair < rational , rational >> ; using derived_unit = std :: unordered_map < Dim , std :: pair < rational , rational >> ; int main () { auto reduce = []( Dim d , std :: pair < rational , rational > left , std :: pair < rational , rational > right ){ using std :: min ; return U { d , { left . first + right . first , min ( left . second , right . second )}}; }; auto implies = [ = ]( derived_unit left , derived_unit right ){ derived_unit result {}; for ( auto const & A : left ) { [ & ]{ for ( auto const & B : right ) { if ( A . first == B . first ) { result . emplace_hint ( result . end (), reduce ( A . first , A . second , B . second )); right . erase ( B . first ); return ; } } result . emplace_hint ( result . end (), A ); }(); } for ( auto const & e : right ) result . insert ( e ); return result ; }; using std :: pair ; derived_unit left = { { Dim :: length , { rational ( 2 ), rational ( 1 ) } }, { Dim :: time , { rational ( - 1 ), rational ( 1 ) } }, }; derived_unit right = { { Dim :: mass , { rational ( 1 ), rational ( 1 ) } }, { Dim :: time , { rational ( - 1 ), rational ( 1 ) } }, }; auto res = implies ( left , right ); for ( auto const & e : res ) { std :: cout << boost :: format ( \"(%1%, %2%)_%3% \" ) % e . second . first % e . second . second % e . first ; } } 2nd step: Identifying the components required for type-level programming Component list for type-level programming set of basic dimensions enum class Dim { mass , time , length , //... }; The type itself is already a set. => define class and tag type member class Length { using is_dimension = void ; }; operator== for basic dimensions bool operator == ( Dim a , Dim b ) { return static_cast < std :: underlying_type_t < Dim >> ( a ) == static_cast < std :: underlying_type_t < Dim >> ( b ); } => a meta-function std::is_same type-level rational using rational = boost :: rational < std :: intmax_t > ; => std::ratio A type that can be expressed in one dimension of derived units using U = std :: pair < const Dim , std :: pair < rational , rational >> ; => define class units_t template < class BaseDimension , // base dimension tag class class Exponent , // std::ratio class Scale // std::ratio > class units_t < BaseDimension , Exponent , Scale > derived units representable type using derived_unit = std :: unordered_map < Dim , std :: pair < rational , rational >> ; unordered_map<Key, Value> is a sequence of std::pair<const Key, Value> . So we need a sequence of units_t. We can use variadic templates. => a class templates template < class ... UnitsT > struct dimensional_t { }; helper function reduce auto reduce = []( Dim d , std :: pair < rational , rational > left , std :: pair < rational , rational > right ){ using std :: min ; return U { d , { left . first + right . first , min ( left . second , right . second )} }; }; => meta-function template < class D , class Exp1 , class Exp2 , class S1 , class S2 > struct reduce < units_t < D , Exp1 , S1 > , units_t < D , Exp2 , S2 >> { using type = std :: conditional_t < std :: ratio_equal_v < std :: ratio_add < Exp1 , Exp2 > , std :: ratio < 0 >> , dimensionless < dimension_tag < D , ratio_max < Exp1 , Exp2 >>> , units_t < D , std :: ratio_add < Exp1 , Exp2 > , ratio_min < S1 , S2 >>> ; }; main loop Put spirit into recursive class template instantiation. template < class ... > struct type_list {}; template < class , class , class , class = void > struct quotient_ ; template < class SP , class Head , class ... Tail , class ... Remainders > struct quotient_ < SP , type_list < Head , Tail ... > , type_list < Remainders ... >> : std :: conditional_t < std :: is_same_v < typename SP :: dimension_type , typename Head :: dimension_type > , quotient_ < SP , type_list <> , type_list < Remainders ..., Tail ... > , typename reduce < SP , Head >:: type > , quotient_ < SP , type_list < Tail ... > , type_list < Remainders ..., Head >>> {}; template < class SP , class Inter , class ... Tail , class ... Remainders > struct quotient_ < SP , type_list < Tail ... > , type_list < Remainders ... > , Inter > { using result = type_list < Inter > ; using remainder = type_list < Tail ..., Remainders ... > ; }; template < class SP , class ... Remainders > struct quotient_ < SP , type_list <> , type_list < Remainders ... >> { using result = type_list < SP > ; using remainder = type_list < Remainders ... > ; }; template < class , class , class > struct quotient_impl ; template < class Head , class ... Tail , class ... R , class ... Results > struct quotient_impl < type_list < Head , Tail ... > , type_list < R ... > , type_list < Results ... >> : quotient_impl < type_list < Tail ... > , typename quotient_ < Head , type_list < R ... > , type_list <>>:: remainder , mitamagic :: tlist_cat_t < type_list < Results ... > , typename quotient_ < Head , type_list < R ... > , type_list <>>:: result >> {}; template < class ... R , class ... Results > struct quotient_impl < type_list <> , type_list < R ... > , type_list < Results ... >> { using result_type = dimensional_t < Results ..., R ... > ; }; // quotient facade // Quotient = Dim -> Dim -> Dim template < class , class > struct quotient ; template < class ... LeftPhantomTypes , class ... RightPhantomTypes > struct quotient < dimensional_t < LeftPhantomTypes ... > , dimensional_t < RightPhantomTypes ... >> { using type = mitamagic :: tlist_remove_if_t < is_dimensionless_type , typename mitamagic :: quotient_impl < mitamagic :: type_list < LeftPhantomTypes ... > , mitamagic :: type_list < RightPhantomTypes ... > , mitamagic :: type_list <> >:: result_type > ; };","title":"Dive into type-level programing"},{"location":"UserManual/basic-concepts/#conclusion","text":"It's a good idea to start by identifying what you need for type-level programming through runtime programming. By using phantom-type idiom, we can distinguish one type in various ways. C++ doesn't have a convenient language extension like Haskell, so we try hard at doing linear searches by relying on types. By using variadic templates, we can handle any dimension as long as the template recursion allows .","title":"Conclusion"},{"location":"UserManual/delta-type/","text":"Delta type Delta type is a type to represent the difference of dimensional quantity. Typical use case is temperature difference. Assigning quantity<kelvin_t> to quantity <degree_celsius_t> will convert that value. However, delta<quantity<kelvin_t >> is a type representing temperature difference, so it is assigned without conversion. // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/si/kelvin.hpp> #include <dimensional/systems/nonsi/degree_celsius.hpp> #include <dimensional/delta.hpp> #include <dimensional/arithmetic.hpp> int main () { using namespace mitama ; namespace si = systems :: si ; namespace nonsi = systems :: nonsi ; quantity < nonsi :: degree_celsius_t > c = 100 ; // Calculated without unit conversion // because it is a temperature difference. // 20 - 10 = 10 delta kelvin <=> 10 delta degree celcius quantity < nonsi :: degree_celsius_t > res = c + delta ( ( 20 | si :: kelvins ) - ( 10 | si :: kelvins ) ); } // end example","title":"Delta type"},{"location":"UserManual/delta-type/#delta-type","text":"Delta type is a type to represent the difference of dimensional quantity. Typical use case is temperature difference. Assigning quantity<kelvin_t> to quantity <degree_celsius_t> will convert that value. However, delta<quantity<kelvin_t >> is a type representing temperature difference, so it is assigned without conversion. // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/si/kelvin.hpp> #include <dimensional/systems/nonsi/degree_celsius.hpp> #include <dimensional/delta.hpp> #include <dimensional/arithmetic.hpp> int main () { using namespace mitama ; namespace si = systems :: si ; namespace nonsi = systems :: nonsi ; quantity < nonsi :: degree_celsius_t > c = 100 ; // Calculated without unit conversion // because it is a temperature difference. // 20 - 10 = 10 delta kelvin <=> 10 delta degree celcius quantity < nonsi :: degree_celsius_t > res = c + delta ( ( 20 | si :: kelvins ) - ( 10 | si :: kelvins ) ); } // end example","title":"Delta type"},{"location":"UserManual/dimensional-quantifiers/","text":"Dimensional quantifiers \"There is both of light and dark inside C++. The important thing is to choose what we write. That's the real of C++.\" Dimensional quantifiers are defined as constexpr variables (templates) of dimensional_t. For example, inline constexpr meter_t meters ; template < std :: intmax_t N = 1 > inline constexpr powered_t < meter_t , N > meter ; If you do not specify the exponent (=1), use the plural dimension quantifiers, and if you specify it, use the singular dimension quantifiers with non-type template parameter. pipe operator overload Pipe operators are provided to attach units to values. It is allowed to convert values into quantities by piping a value to dimensional quantifiers. example // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/si/all.hpp> int main () { namespace si = mitama :: systems :: si ; using mitama :: quantity_t ; // Template argument deduction for class templates quantity_t mass = 3 | si :: kilograms ; // 3 [kg] quantity_t time = 1.66 | si :: seconds ; // 1.66 [s] quantity_t volume = 4 | si :: meter < 3 > ; // 4 [m^3] } // end example multiplication and division operators Multiplication and division operators for dimensional quantifiers are provided to make derived units. // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/si/all.hpp> int main () { namespace si = mitama :: systems :: si ; using mitama :: quantity_t ; // Template argument deduction for class templates quantity_t density = 3 | si :: kilograms / si :: meter < 3 > ; // 3 [kg / m^3] quantity_t speed = 1.2 | si :: meters / si :: seconds ; // 1.2 [m / s] quantity_t accel = 4 | si :: meters * si :: second <- 2 > ; // 4 [s / m^2] } // end example","title":"Dimensional quantifiers"},{"location":"UserManual/dimensional-quantifiers/#dimensional-quantifiers","text":"\"There is both of light and dark inside C++. The important thing is to choose what we write. That's the real of C++.\" Dimensional quantifiers are defined as constexpr variables (templates) of dimensional_t. For example, inline constexpr meter_t meters ; template < std :: intmax_t N = 1 > inline constexpr powered_t < meter_t , N > meter ; If you do not specify the exponent (=1), use the plural dimension quantifiers, and if you specify it, use the singular dimension quantifiers with non-type template parameter.","title":"Dimensional quantifiers"},{"location":"UserManual/dimensional-quantifiers/#pipe-operator-overload","text":"Pipe operators are provided to attach units to values. It is allowed to convert values into quantities by piping a value to dimensional quantifiers. example // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/si/all.hpp> int main () { namespace si = mitama :: systems :: si ; using mitama :: quantity_t ; // Template argument deduction for class templates quantity_t mass = 3 | si :: kilograms ; // 3 [kg] quantity_t time = 1.66 | si :: seconds ; // 1.66 [s] quantity_t volume = 4 | si :: meter < 3 > ; // 4 [m^3] } // end example","title":"pipe operator overload"},{"location":"UserManual/dimensional-quantifiers/#multiplication-and-division-operators","text":"Multiplication and division operators for dimensional quantifiers are provided to make derived units. // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/si/all.hpp> int main () { namespace si = mitama :: systems :: si ; using mitama :: quantity_t ; // Template argument deduction for class templates quantity_t density = 3 | si :: kilograms / si :: meter < 3 > ; // 3 [kg / m^3] quantity_t speed = 1.2 | si :: meters / si :: seconds ; // 1.2 [m / s] quantity_t accel = 4 | si :: meters * si :: second <- 2 > ; // 4 [s / m^2] } // end example","title":"multiplication and division operators"},{"location":"UserManual/dimensional-quantity-101/","text":"Dimensional quantity 101 \"Dark and difficult times lie ahead. Soon we must all face the choice between what is right and what is easy.\" \u2015 Albus Dumbledore, Harry Potter and the Goblet of Fire Unit systems There are three basic unit systems in use today: the International System of Units (SI units, from Syst\u00e8me international d'unit\u00e9s, more commonly simply called metric units) the English Engineering System of Units (commonly called English units) the British Gravitational System of Units (BG) This library only supports SI units by library default. Base units and dimensions Base units have the important property that all other units derive from them. In the SI system, there are seven such base units and corresponding physical quantities: meter (m) for length, kilogram (kg) for mass, second (s) for time, kelvin (K) for temperature, ampere (A) for electric current, candela (cd) for luminous intensity, and mole (mol) for the amount of substance. Mathematical Notation We need some suitable mathematical notation to calculate with dimensions like length, mass, time, and so forth. The dimension of length is written as [ L ], the dimension of mass as [ M ] and the dimension of time as [ T ]. The dimension of a derived unit like velocity, which is distance (length) divided by time, then becomes [ LT^{-1} ] in this notation. The dimension of force, another derived unit, is the same as the dimension of mass times acceleration, and hence the dimension of force is [ MLT^{-2} ]. Now let's think about multiplication and division of dimensional quantities. For example, a [m] \\times b [s] = c [m \\cdot s] m \\cdot s is a new unit different from both of metre and second, and can give a clear meaning that m \\cdot s is proportional to both of metre and second. And m / s is proportional to metre and inversely proportional to second. Also, m /s \\times s derives m . Dimensions of common physical quantities Many derived quantities are measured in derived units that have their own name. Force is one example: Newton (N) is a derived unit for force, equal to kg \\cdot m \\cdot s^{-2} . Another derived unit is Pascal (Pa) for pressure, i.e., force per area. The unit of Pa then equals N/m^2 or kg \\cdot m^{-1} \\cdot s^{-2} . Below are more names for derived quantities, listed with their units. Name Symbol Physical quantity Unit radian rad angle 1 hertz Hz frequency s^{-1} newton N force, weight kg \\cdot m \\cdot s^{-2} pascal Pa pressure, stress N/m^2 joule J energy, work, heat N \\times m watt W power J/s Some common physical quantities and their dimensions are listed next. Quantity Relation Unit Dimension pressure force/area N \\cdot m^{-2}=Pa [ MT^{-2}L^{-1} ] density mass/volume kg \\cdot m^{-3} [ ML^{-3} ] strain displacement/length 1 [ 1 ] Young's modulus stress/strain N \\cdot m^{-2}=Pa [ MT^{-2}L^{-1} ] Poisson's ratio transverse strain/axial strain 1 [ 1 ] moment (of force) distance \\times force N \\cdot m [ ML^2T^{-2} ] impulse force \\times time N \\cdot s [ MLT^{-1} ] linear momentum mass \\times velocity kg m \\cdot s^{-1} [ MLT^{-1} ] angular momentum distance \\times mass \\times velocity kg \\cdot m^2 \\cdot s^{-1} [ ML^2T^{-1} ] work force \\times distance N \\cdot m=J [ ML^2T^{-2} ] energy work N \\cdot m=J [ ML^2T^{-2} ] power work/time N \\cdot m \\cdot s^{-1}=W [ ML^2T^{-3} ] heat work J [ ML^2T^{-2} ] heat flux heat rate/area W \\cdot m^{-2} [ MT^{-3} ] temperature base unit K [ \\Theta ] heat capacity heat change J/K [ ML^2T^{-2}\\Theta^{-1} ] specific heat capacity heat capacity/unit mass J \\cdot K^{-1} \\cdot kg^{-1} [ L^2T^{-2}\\Theta^{-1} ] thermal conductivity heat flux/temperature gradient W \\cdot m^{-1} \\cdot K^{-1} [ MLT^{-3}\\Theta^{-1} ] dynamic viscosity shear stress/velocity gradient kg \\cdot m^{-1} \\cdot s^{-1} [ ML^{-1}T^{-1} ] kinematic viscosity dynamic viscosity/density m^2/s [ L^2T^{-1} ] surface tension energy/area J \\cdot s^{-2} [ MT^{-2} ] Metric Prefix A metric prefix is a unit prefix that precedes a basic unit of measure to indicate a multiple or fraction of the unit. Each prefix has a unique symbol that is prepended to the unit symbol. The prefix kilo- , for example, may be added to gram to indicate multiplication by one thousand; one kilogram is equal to one thousand grams. The prefix mili- , likewise, may be added to metre to indicate division by one thousand; one milimetre is equal to one thousand of a metre. The SI prefixes are standardized for use in the International System of Units (SI units). Text Symbol Factor Power yotta Y 1000000000000000000000000 10^{24} zetta Z 1000000000000000000000 10^{21} exa E 1000000000000000000 10^{18} peta P 1000000000000000 10^{15} tera T 1000000000000 10^{12} giga G 1000000000 10^9 mega M 1000000 10^6 kilo k 1000 10^3 hecto h 100 10^2 deca da 10 10^1 Text Symbol Factor Power deci d 0.1 10^{-1} centi c 0.01 10^{-2} milli m 0.001 10^{-3} micro u 0.000001 10^{-6} nano n 0.000000001 10^{-9} pico p 0.000000000001 10^{-12} femto f 0.000000000000001 10^{-15} atto a 0.000000000000000001 10^{-18} zepto z 0.000000000000000000001 10^{-21} yocto y 0.000000000000000000000001 10^{-24}","title":"Dimensional quantity 101"},{"location":"UserManual/dimensional-quantity-101/#dimensional-quantity-101","text":"\"Dark and difficult times lie ahead. Soon we must all face the choice between what is right and what is easy.\" \u2015 Albus Dumbledore, Harry Potter and the Goblet of Fire","title":"Dimensional quantity 101"},{"location":"UserManual/dimensional-quantity-101/#unit-systems","text":"There are three basic unit systems in use today: the International System of Units (SI units, from Syst\u00e8me international d'unit\u00e9s, more commonly simply called metric units) the English Engineering System of Units (commonly called English units) the British Gravitational System of Units (BG) This library only supports SI units by library default.","title":"Unit systems"},{"location":"UserManual/dimensional-quantity-101/#base-units-and-dimensions","text":"Base units have the important property that all other units derive from them. In the SI system, there are seven such base units and corresponding physical quantities: meter (m) for length, kilogram (kg) for mass, second (s) for time, kelvin (K) for temperature, ampere (A) for electric current, candela (cd) for luminous intensity, and mole (mol) for the amount of substance.","title":"Base units and dimensions"},{"location":"UserManual/dimensional-quantity-101/#mathematical-notation","text":"We need some suitable mathematical notation to calculate with dimensions like length, mass, time, and so forth. The dimension of length is written as [ L ], the dimension of mass as [ M ] and the dimension of time as [ T ]. The dimension of a derived unit like velocity, which is distance (length) divided by time, then becomes [ LT^{-1} ] in this notation. The dimension of force, another derived unit, is the same as the dimension of mass times acceleration, and hence the dimension of force is [ MLT^{-2} ]. Now let's think about multiplication and division of dimensional quantities. For example, a [m] \\times b [s] = c [m \\cdot s] m \\cdot s is a new unit different from both of metre and second, and can give a clear meaning that m \\cdot s is proportional to both of metre and second. And m / s is proportional to metre and inversely proportional to second. Also, m /s \\times s derives m .","title":"Mathematical Notation"},{"location":"UserManual/dimensional-quantity-101/#dimensions-of-common-physical-quantities","text":"Many derived quantities are measured in derived units that have their own name. Force is one example: Newton (N) is a derived unit for force, equal to kg \\cdot m \\cdot s^{-2} . Another derived unit is Pascal (Pa) for pressure, i.e., force per area. The unit of Pa then equals N/m^2 or kg \\cdot m^{-1} \\cdot s^{-2} . Below are more names for derived quantities, listed with their units. Name Symbol Physical quantity Unit radian rad angle 1 hertz Hz frequency s^{-1} newton N force, weight kg \\cdot m \\cdot s^{-2} pascal Pa pressure, stress N/m^2 joule J energy, work, heat N \\times m watt W power J/s Some common physical quantities and their dimensions are listed next. Quantity Relation Unit Dimension pressure force/area N \\cdot m^{-2}=Pa [ MT^{-2}L^{-1} ] density mass/volume kg \\cdot m^{-3} [ ML^{-3} ] strain displacement/length 1 [ 1 ] Young's modulus stress/strain N \\cdot m^{-2}=Pa [ MT^{-2}L^{-1} ] Poisson's ratio transverse strain/axial strain 1 [ 1 ] moment (of force) distance \\times force N \\cdot m [ ML^2T^{-2} ] impulse force \\times time N \\cdot s [ MLT^{-1} ] linear momentum mass \\times velocity kg m \\cdot s^{-1} [ MLT^{-1} ] angular momentum distance \\times mass \\times velocity kg \\cdot m^2 \\cdot s^{-1} [ ML^2T^{-1} ] work force \\times distance N \\cdot m=J [ ML^2T^{-2} ] energy work N \\cdot m=J [ ML^2T^{-2} ] power work/time N \\cdot m \\cdot s^{-1}=W [ ML^2T^{-3} ] heat work J [ ML^2T^{-2} ] heat flux heat rate/area W \\cdot m^{-2} [ MT^{-3} ] temperature base unit K [ \\Theta ] heat capacity heat change J/K [ ML^2T^{-2}\\Theta^{-1} ] specific heat capacity heat capacity/unit mass J \\cdot K^{-1} \\cdot kg^{-1} [ L^2T^{-2}\\Theta^{-1} ] thermal conductivity heat flux/temperature gradient W \\cdot m^{-1} \\cdot K^{-1} [ MLT^{-3}\\Theta^{-1} ] dynamic viscosity shear stress/velocity gradient kg \\cdot m^{-1} \\cdot s^{-1} [ ML^{-1}T^{-1} ] kinematic viscosity dynamic viscosity/density m^2/s [ L^2T^{-1} ] surface tension energy/area J \\cdot s^{-2} [ MT^{-2} ]","title":"Dimensions of common physical quantities"},{"location":"UserManual/dimensional-quantity-101/#metric-prefix","text":"A metric prefix is a unit prefix that precedes a basic unit of measure to indicate a multiple or fraction of the unit. Each prefix has a unique symbol that is prepended to the unit symbol. The prefix kilo- , for example, may be added to gram to indicate multiplication by one thousand; one kilogram is equal to one thousand grams. The prefix mili- , likewise, may be added to metre to indicate division by one thousand; one milimetre is equal to one thousand of a metre. The SI prefixes are standardized for use in the International System of Units (SI units). Text Symbol Factor Power yotta Y 1000000000000000000000000 10^{24} zetta Z 1000000000000000000000 10^{21} exa E 1000000000000000000 10^{18} peta P 1000000000000000 10^{15} tera T 1000000000000 10^{12} giga G 1000000000 10^9 mega M 1000000 10^6 kilo k 1000 10^3 hecto h 100 10^2 deca da 10 10^1 Text Symbol Factor Power deci d 0.1 10^{-1} centi c 0.01 10^{-2} milli m 0.001 10^{-3} micro u 0.000001 10^{-6} nano n 0.000000001 10^{-9} pico p 0.000000000001 10^{-12} femto f 0.000000000000001 10^{-15} atto a 0.000000000000000001 10^{-18} zepto z 0.000000000000000000001 10^{-21} yocto y 0.000000000000000000000001 10^{-24}","title":"Metric Prefix"},{"location":"UserManual/dimensional-refinement/","text":"Dimensional refinement \"I mean, it's sort of exciting, isn't it, breaking the rules?\" \u2014 Hermione Granger, Harry Potter and the Order of the Phoenix Defined in header <dimensional/refinement.hpp> . Refinement type A function that can be guaranteed at compile time to have dimensions in accordance with the purpose while inferring units of quantity type. The following is a compilation error if the quantity (2 | meters) * (7 | meters) does not have the dimension of area L^2 completely. This code can be compiled through refinement, since m^2 is of dimension L^2 . quantity_t a1 = accepts < area_r > |= ( 2 | meters ) * ( 7 | meters ); If you want to specify the unit should be written as follows. The difference is that automatic unit conversion is performed when units are different. accepts examines only the dimensions, not the units. quantity < meter_t , int > a1 = ( 2 | meters ) * ( 7 | meters ); The following example does not compile. This is because m is the dimension of L and not L^2 . quantity_t a3 = accepts < area_r > |= ( 2 | millimeters ); // error! Partial refinement type The following is a compilation error if the quantity (2 | meters) * (2 | meters) * (2 | kilograms) / (2 | second <2>) does not partially have the dimension of mass M . The compilation passes because it actually has. quantity_t a3 = partial_accepts < sym :: M <>> |= ( 2 | meters ) * ( 2 | meters ) * ( 2 | kilograms ) / ( 2 | second < 2 > );","title":"Dimensional refinement"},{"location":"UserManual/dimensional-refinement/#dimensional-refinement","text":"\"I mean, it's sort of exciting, isn't it, breaking the rules?\" \u2014 Hermione Granger, Harry Potter and the Order of the Phoenix Defined in header <dimensional/refinement.hpp> .","title":"Dimensional refinement"},{"location":"UserManual/dimensional-refinement/#refinement-type","text":"A function that can be guaranteed at compile time to have dimensions in accordance with the purpose while inferring units of quantity type. The following is a compilation error if the quantity (2 | meters) * (7 | meters) does not have the dimension of area L^2 completely. This code can be compiled through refinement, since m^2 is of dimension L^2 . quantity_t a1 = accepts < area_r > |= ( 2 | meters ) * ( 7 | meters ); If you want to specify the unit should be written as follows. The difference is that automatic unit conversion is performed when units are different. accepts examines only the dimensions, not the units. quantity < meter_t , int > a1 = ( 2 | meters ) * ( 7 | meters ); The following example does not compile. This is because m is the dimension of L and not L^2 . quantity_t a3 = accepts < area_r > |= ( 2 | millimeters ); // error!","title":"Refinement type"},{"location":"UserManual/dimensional-refinement/#partial-refinement-type","text":"The following is a compilation error if the quantity (2 | meters) * (2 | meters) * (2 | kilograms) / (2 | second <2>) does not partially have the dimension of mass M . The compilation passes because it actually has. quantity_t a3 = partial_accepts < sym :: M <>> |= ( 2 | meters ) * ( 2 | meters ) * ( 2 | kilograms ) / ( 2 | second < 2 > );","title":"Partial refinement type"},{"location":"UserManual/expression-templates/","text":"Expression templates Addition of celsius temperature and absolute temperature is possible by performing a conversion. However, there is a problem. Compiler do not know if it would be nice if the result could be adjusted to either unit. In order to solve this problem, an expression template is used. An expression template creates a temporary object and delays unit calculation until assignment. Determine how to perform unit conversion from the dimension of assignment destination. // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/nonsi/degree_celsius.hpp> #include <dimensional/expr.hpp> int main (){ namespace si = mitama :: systems :: si ; namespace nonsi = mitama :: systems :: nonsi ; using mitama :: quantity , mitama :: as_expr ; quantity < decltype ( si :: kelvin <> / si :: second <> ) > x = as_expr ( 1 | si :: kelvins ) / ( 2 | si :: seconds ) + as_expr ( 2 | nonsi :: degree_celsius ) / ( 2 | si :: seconds ); // x = 137.575 [K/s] quantity < decltype ( si :: kelvin <> / si :: second <> ) > y = ( as_expr ( 11 | si :: kelvins ) - as_expr ( 1 | si :: kelvins )) / ( 2 | si :: seconds ) + ( as_expr ( 21 | nonsi :: degree_celsius ) - as_expr ( 1 | nonsi :: degree_celsius )) / ( 2 | si :: seconds ); // x = 15 [K/s] } // end example","title":"Expression templates"},{"location":"UserManual/expression-templates/#expression-templates","text":"Addition of celsius temperature and absolute temperature is possible by performing a conversion. However, there is a problem. Compiler do not know if it would be nice if the result could be adjusted to either unit. In order to solve this problem, an expression template is used. An expression template creates a temporary object and delays unit calculation until assignment. Determine how to perform unit conversion from the dimension of assignment destination. // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/nonsi/degree_celsius.hpp> #include <dimensional/expr.hpp> int main (){ namespace si = mitama :: systems :: si ; namespace nonsi = mitama :: systems :: nonsi ; using mitama :: quantity , mitama :: as_expr ; quantity < decltype ( si :: kelvin <> / si :: second <> ) > x = as_expr ( 1 | si :: kelvins ) / ( 2 | si :: seconds ) + as_expr ( 2 | nonsi :: degree_celsius ) / ( 2 | si :: seconds ); // x = 137.575 [K/s] quantity < decltype ( si :: kelvin <> / si :: second <> ) > y = ( as_expr ( 11 | si :: kelvins ) - as_expr ( 1 | si :: kelvins )) / ( 2 | si :: seconds ) + ( as_expr ( 21 | nonsi :: degree_celsius ) - as_expr ( 1 | nonsi :: degree_celsius )) / ( 2 | si :: seconds ); // x = 15 [K/s] } // end example","title":"Expression templates"},{"location":"UserManual/metric-prefixes/","text":"Metric prefixes Metric prefix constants for dimensional quantifiers definition namespace mitama :: systems :: si { inline constexpr auto pico = std :: pico {}; inline constexpr auto nano = std :: nano {}; inline constexpr auto micro = std :: micro {}; inline constexpr auto milli = std :: milli {}; inline constexpr auto centi = std :: centi {}; inline constexpr auto deci = std :: deci {}; inline constexpr auto deca = std :: deca {}; inline constexpr auto hecto = std :: hecto {}; inline constexpr auto kilo = std :: kilo {}; inline constexpr auto mega = std :: mega {}; inline constexpr auto giga = std :: giga {}; inline constexpr auto tera = std :: tera {}; } Usage // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/si/all.hpp> #include <dimensional/systems/si/prefix.hpp> int main () { using mitama :: quantity_t ; namespace si = mitama :: systems :: si ; quantity_t a = ( 1 | si :: giga * si :: meters ); // 1 [Gm] } // end example","title":"Metric prefixes"},{"location":"UserManual/metric-prefixes/#metric-prefixes","text":"","title":"Metric prefixes"},{"location":"UserManual/metric-prefixes/#metric-prefix-constants-for-dimensional-quantifiers","text":"definition namespace mitama :: systems :: si { inline constexpr auto pico = std :: pico {}; inline constexpr auto nano = std :: nano {}; inline constexpr auto micro = std :: micro {}; inline constexpr auto milli = std :: milli {}; inline constexpr auto centi = std :: centi {}; inline constexpr auto deci = std :: deci {}; inline constexpr auto deca = std :: deca {}; inline constexpr auto hecto = std :: hecto {}; inline constexpr auto kilo = std :: kilo {}; inline constexpr auto mega = std :: mega {}; inline constexpr auto giga = std :: giga {}; inline constexpr auto tera = std :: tera {}; } Usage // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/si/all.hpp> #include <dimensional/systems/si/prefix.hpp> int main () { using mitama :: quantity_t ; namespace si = mitama :: systems :: si ; quantity_t a = ( 1 | si :: giga * si :: meters ); // 1 [Gm] } // end example","title":"Metric prefix constants for dimensional quantifiers"},{"location":"UserManual/mitama_quantity_t/","text":"mitama::quantity_t Defined in header <dimensional/quantity.hpp> quantity_t<Units, T> is a class that represents a dimensional quantity of Units that has value type of T . definition namespace mitama { template < class Units , // phantom type class T = double // underlying type > class quantity_t ; template < class Units , class T = double > using quantity = quantity_t < Units , T > ; } Note If the second template argument is omitted, it will be of type double . example: // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/si/all.hpp> int main () { namespace si = mitama :: systems :: si ; using mitama :: quantity_t ; quantity_t < si :: meter_t , int > len1 = 1 ; // 1 [m] quantity_t < si :: meter_t , double > len2 = 1.45 ; // 1.45 [m] } // end example conversions Conversion between different units is performed automatically. Conversion between units with different dimensions will result in compilation errors. example: // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/si/all.hpp> int main () { namespace si = mitama :: systems :: si ; using mitama :: quantity_t ; quantity_t a = 3 | si :: kilograms ; quantity_t < si :: gram_t , int > b = a ; // 3000 [g] // quantity_t<si::meter_t, int> b = a; // compile error! } // end example arithmetic operators Defined in header <dimensional/arithmetic.hpp> Let q1 is a value with type of quantity_t<D1, T1> , q2 is a value with type of quantity_t<D2, T2> and v is a value with type of T3 . And arithmetic operators listed bellow are defined: expression condition q1 + q2 D1 and D2 has same dimension and std::declval<T1>() + std::declval<T2>() is valid expression q1 - q2 D1 and D2 has same dimension and std::declval<T1>() - std::declval<T2>() is valid expression q1 * q2 std::declval<T1>() * std::declval<T2>() is valid expression q1 / q2 std::declval<T1>() / std::declval<T2>() is valid expression q1 * v std::declval<T1>() * std::declval<T3>() is valid expression v * q1 std::declval<T3>() * std::declval<T1>() is valid expression q1 / v std::declval<T1>() / std::declval<T3>() is valid expression v / q1 std::declval<T3>() / std::declval<T1>() is valid expression Otherwise, arithmetic operators do not participate in overload resolution. example: // begin example #include <dimensional/quantity.hpp> #include <dimensional/arithmetic.hpp> #include <dimensional/systems/si/all.hpp> int main () { namespace si = mitama :: systems :: si ; using mitama :: quantity_t ; quantity_t a = 4 | si :: meters ; quantity_t b = 2 | si :: meters ; a + b ; // 6 [m] a - b ; // 2 [m] a * b ; // 8 [m^2] a / b ; // 2 [dimensionless] 2 * b ; // 8 [m] b * 2 ; // 8 [m] b / 2 ; // 1 [m] 2 / b ; // 1 [m^-1] } // end example Unit conversions If unit conversion occurs, it is always converted to the higher precision. For example, meters plus millimeters convert meters to millimeters. example: // begin example #include <dimensional/quantity.hpp> #include <dimensional/arithmetic.hpp> #include <dimensional/systems/si/all.hpp> int main () { namespace si = mitama :: systems :: si ; using mitama :: quantity_t ; quantity_t a = 4 | si :: meters ; quantity_t b = 2 | si :: millimeters ; a + b ; // 4002 [mm] a - b ; // 3998 [mm] a * b ; // 8000 [mm^2] a / b ; // 2000 [dimensionless] } // end example","title":"Quantity"},{"location":"UserManual/mitama_quantity_t/#mitamaquantity_t","text":"Defined in header <dimensional/quantity.hpp> quantity_t<Units, T> is a class that represents a dimensional quantity of Units that has value type of T . definition namespace mitama { template < class Units , // phantom type class T = double // underlying type > class quantity_t ; template < class Units , class T = double > using quantity = quantity_t < Units , T > ; } Note If the second template argument is omitted, it will be of type double . example: // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/si/all.hpp> int main () { namespace si = mitama :: systems :: si ; using mitama :: quantity_t ; quantity_t < si :: meter_t , int > len1 = 1 ; // 1 [m] quantity_t < si :: meter_t , double > len2 = 1.45 ; // 1.45 [m] } // end example","title":"mitama::quantity_t"},{"location":"UserManual/mitama_quantity_t/#conversions","text":"Conversion between different units is performed automatically. Conversion between units with different dimensions will result in compilation errors. example: // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/si/all.hpp> int main () { namespace si = mitama :: systems :: si ; using mitama :: quantity_t ; quantity_t a = 3 | si :: kilograms ; quantity_t < si :: gram_t , int > b = a ; // 3000 [g] // quantity_t<si::meter_t, int> b = a; // compile error! } // end example","title":"conversions"},{"location":"UserManual/mitama_quantity_t/#arithmetic-operators","text":"Defined in header <dimensional/arithmetic.hpp> Let q1 is a value with type of quantity_t<D1, T1> , q2 is a value with type of quantity_t<D2, T2> and v is a value with type of T3 . And arithmetic operators listed bellow are defined: expression condition q1 + q2 D1 and D2 has same dimension and std::declval<T1>() + std::declval<T2>() is valid expression q1 - q2 D1 and D2 has same dimension and std::declval<T1>() - std::declval<T2>() is valid expression q1 * q2 std::declval<T1>() * std::declval<T2>() is valid expression q1 / q2 std::declval<T1>() / std::declval<T2>() is valid expression q1 * v std::declval<T1>() * std::declval<T3>() is valid expression v * q1 std::declval<T3>() * std::declval<T1>() is valid expression q1 / v std::declval<T1>() / std::declval<T3>() is valid expression v / q1 std::declval<T3>() / std::declval<T1>() is valid expression Otherwise, arithmetic operators do not participate in overload resolution. example: // begin example #include <dimensional/quantity.hpp> #include <dimensional/arithmetic.hpp> #include <dimensional/systems/si/all.hpp> int main () { namespace si = mitama :: systems :: si ; using mitama :: quantity_t ; quantity_t a = 4 | si :: meters ; quantity_t b = 2 | si :: meters ; a + b ; // 6 [m] a - b ; // 2 [m] a * b ; // 8 [m^2] a / b ; // 2 [dimensionless] 2 * b ; // 8 [m] b * 2 ; // 8 [m] b / 2 ; // 1 [m] 2 / b ; // 1 [m^-1] } // end example","title":"arithmetic operators"},{"location":"UserManual/mitama_quantity_t/#unit-conversions","text":"If unit conversion occurs, it is always converted to the higher precision. For example, meters plus millimeters convert meters to millimeters. example: // begin example #include <dimensional/quantity.hpp> #include <dimensional/arithmetic.hpp> #include <dimensional/systems/si/all.hpp> int main () { namespace si = mitama :: systems :: si ; using mitama :: quantity_t ; quantity_t a = 4 | si :: meters ; quantity_t b = 2 | si :: millimeters ; a + b ; // 4002 [mm] a - b ; // 3998 [mm] a * b ; // 8000 [mm^2] a / b ; // 2000 [dimensionless] } // end example","title":"Unit conversions"},{"location":"UserManual/si-derived-units/","text":"Library defined units and format Format IO std::ostream adaptor operator << is defined in header <dimensional/io.hpp> . example // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/si/all.hpp> #include <dimensional/io.hpp> int main () { using mitama :: quantity_t ; namespace si = mitama :: systems :: si ; quantity_t a = 1 | si :: meters ; std :: cout << a << '\\n' ; // 1 [m] } // end example SI basic units type name quantifier name Unit symbol Quantity measured metre_t/meter_t metre/meter m length kilogram_t kilogram kg mass second_t second s time ampere_t ampere A electric current kelvin_t kelvin K temperature mole_t mole mol amount of substance candela_t candela cd luminous intensity Non SI units type name quantifier name Unit symbol Equivalents in terms of SI units hectare_t hectare ha 1\\ ha = 10^4\\ m^2 litre_t/liter_t litre/liter L 1\\ L = 10^{-3}\\ m^3 tonne_t tonne t 1\\ t = 10^3\\ kg au_t au au 1\\ au = 149,597,870,700\\ m minute_t minutes min 1\\ min = 60\\ s hour_t hours h 1\\ h = 60\\ min = 3600\\ s day_t days d 1\\ d = 24\\ h = 86400\\ s Named units derived from SI base units type name quantifier Name Symbol Quantity Equivalents SI base unit Equivalents hertz_t hertz Hz frequency 1/s s^{-1} radian_t radian rad angle m/m 1 steradian_t steradian sr solid angle m^2/m^2 1 newton_t newton N force weight kg \\cdot m/s^2 kg \\cdot m \\cdot s^{-2} pascal_t pascal Pa pressure stress N/m^2 kg \\cdot m^{-1} \\cdot s^{-2} joule_t joule J energy work heat N \\cdot m \\\\ C \\cdot V \\\\ W \\cdot s kg \\cdot m^2 \\cdot s^{-2} watt_t watt W power radiant flux J/s \\\\ V \\cdot A kg \\cdot m^2 \\cdot s^{-3} coulomb_t coulomb C electric charge quantity of electricity s \\cdot A \\\\ F \\cdot V s \\cdot A volt_t volt V voltage electrical potential difference W/A \\\\ J/C kg \\cdot m^2 \\cdot s^{-3} \\cdot A^{-1} farad_t farad F electrical capacitance C/V \\\\ s/\\Omega kg^{-1} \\cdot m^{-2} \\cdot s^4 \\cdot A^2 ohm_t ohm \\Omega electrical resistance impedance, reactance 1/S \\\\ V/A kg \\cdot m^2 \\cdot s^{-3} \\cdot A^{-2} siemens_t siemens S electrical conductance 1/\\Omega \\\\ A/V kg^{-1} \\cdot m^{-2} \\cdot s^3 \\cdot A^2 weber_t weber Wb magnetic flux J/A \\\\ T \\cdot m^2 kg \\cdot m^2 \\cdot s^{-2} \\cdot A^{-1} tesla_t tesla T magnetic induction magnetic flux density V \\cdot s/m^2 \\\\ Wb/m^2 \\\\ N/(A \\cdot m) kg \\cdot s^{-2} \\cdot A^{-1} henry_t henry H electrical inductance V \\cdot s/A \\\\ \\Omega \\cdot s \\\\ Wb/A kg \\cdot m^2 \\cdot s^{-2} \\cdot A^{-2} degree_celsius_t degree_celsius \u00b0C temperature relative to 273.15 K K K lumen_t lumen lm luminous flux cd \\cdot sr cd lux_t lux lx illuminance lm/m^2 m^{-2} \\cdot cd becquerel_t becquerel Bq radioactivity (decays per unit time) 1/s s^{-1} gray_t gray Gy absorbed dose (of ionizing radiation) J/kg m^2 \\cdot s^{-2} sievert_t sievert Sv equivalent dose (of ionizing radiation) J/kg m^2 \\cdot s^{-2} katal_t katal kat catalytic activity mol/s s^{-1} \\cdot mol Kinematic SI derived units type name quantifier Name Symbol Expression in termsof SI base units velocity_t velocity m/s m \\cdot s^{-1} acceleration_t acceleration m/s^2 m \\cdot s^{-2} jerk_t jerk m/s^3 m \\cdot s^{-3} snap_t snap m/s^4 m \\cdot s^{-4} crackle_t crackle m/s^5 m \\cdot s^{-5} pop_t pop m/s^6 m \\cdot s^{-6} angular_velocity_t angular_velocity rad/s s^{-1} angular_acceleration_t angular_acceleration rad/s^2 s^{-2} frequency_drift_t frequency_drift Hz/s s^{-2} volumetric_flow_t volumetric_flow m^3/s m^3 \\cdot s^{-1} Molar SI derived units type name quantifier Name Symbol Expression in terms of SI base units molarity_t molarity mol/m^3 m^{-3} \\cdot mol molar_volume_t molar_volume_t m^3/mol m^3 \\cdot mol^{-1} molar_entropy_t molar_entropy J/(K \\cdot mol) m^2 \\cdot kg \\cdot s^{-2} \\cdot K^{-1} \\cdot mol^{-1} molar_heat_capacity_t molar_heat_capacity J/(K \\cdot mol) m^2 \\cdot kg \\cdot s^{-2} \\cdot K^{-1} \\cdot mol^{-1} molar_energy_t molar_energy J/mol m^2 \\cdot kg \\cdot s^{-2} \\cdot mol^{-1} molar_conductivity_t molar_conductivity S \\cdot m^2/mol kg^{-1} \\cdot s^3 \\cdot A^2 \\cdot mol^{-1} molality_t molality mol/kg kg^{-1} \\cdot mol molar_mass_t molar_mass kg/mol kg \\cdot mol^{-1} catalytic_efficiency_t catalytic_efficiency m^3/(mol \\cdot s) m^3 \\cdot s^{-1} \\cdot mol^{-1} Electromagnetic SI derived units type name quantifier Name Symbol Expression in terms of SI base units electric_displacement_field_t electric_displacement_field C/m^2 m^{-2} \\cdot s \\cdot A polarization_density_t polarization_density --- m^{-2} \\cdot s \\cdot A electric_charge_density_t electric_charge_density C/m^3 m^{-3} \\cdot s \\cdot A electric_current_density_t electric_current_density A/m^2 m^{-2} \\cdot A electrical_conductivity_t electrical_conductivity S/m m^{-3} \\cdot kg^{-1} \\cdot s^3 \\cdot A^2 permittivity_t permittivity F/m m^{-3} \\cdot kg^{-1} \\cdot s^4 \\cdot A^2 permeability_t permeability H/m m \\cdot kg \\cdot s^{-2} \\cdot A^{-2} electric_field_strength_t electric_field_strength V/m m \\cdot kg \\cdot s^{-3} \\cdot A^{-1} magnetization_t magnetization A/m m^{-1} \\cdot A exposure_t exposure C/kg kg^{-1} \\cdot s \\cdot A resistivity_t resistivity \\Omega \\cdot m m^3 \\cdot kg \\cdot s^{-3} \\cdot A^{-2} linear_charge_density_t linear_charge_density C/m m^{-1} \\cdot s \\cdot A magnetic_dipole_moment_t magnetic_dipole_moment --- m^2 \\cdot A electron_mobility_t electron_mobility m^2/(V \\cdot s) kg^{-1} \\cdot s^2 \\cdot A magnetic_reluctance_t magnetic_reluctance H^{-1} m^{-2} \\cdot kg^{-1} \\cdot s^2 \\cdot A^2 magnetic_vector_potential_t magnetic_vector_potential Wb/m m \\cdot kg \\cdot s^{-2} \\cdot A^{-1} magnetic_moment_t magnetic_moment Wb \\cdot m m^3 \\cdot kg \\cdot s^{-2} \\cdot A^{-1} magnetic_rigidity_t magnetic_rigidity T \\cdot m m \\cdot kg \\cdot s^{-2} \\cdot A^{-1} magnetomotive_force_t magnetomotive_force --- A magnetic_susceptibility_t magnetic_susceptibility m/H m^{-1} \\cdot kg^{-1} \\cdot s^2 \\cdot A^2 Photometric SI derived units type name quantifier Name Symbol Expression in terms of SI base units luminous_energy_t luminous_energy lm \\cdot s s \\cdot cd \\cdot sr luminous_exposure_t luminous_energy lx \\cdot s m^{-2} \\cdot s \\cdot cd \\cdot sr luminance_t luminous_energy cd/m^2 m^{-2} \\cdot cd luminous_efficacy_t luminous_energy lm/W m^{-2} \\cdot kg^{-1} \\cdot s^3 \\cdot cd \\cdot sr Thermodynamic SI derived units type name quantifier Name Symbol Expression in terms of SI base units heat_capacity_t specific_entropy J/K m^2 \\cdot kg \\cdot s^{-2} \\cdot K^{-1} entropy_t entropy J/K m^2 \\cdot kg \\cdot s^{-2} \\cdot K^{-1} specific_heat_capacity_t specific_heat_capacity J/(K \\cdot kg) m^2 \\cdot s^{-2} \\cdot K^{-1} specific_entropy_t specific_entropy J/(K \\cdot kg) m^2 \\cdot s^{-2} \\cdot K^{-1} thermal_conductivity_t thermal_conductivity W/(m \\cdot K) m \\cdot kg \\cdot s^{-3} \\cdot K^{-1} thermal_resistance_t thermal_resistance K/W m^{-2} \\cdot kg^{-1} \\cdot s^3 \\cdot K thermal_expansion_coefficient_t thermal_expansion_coefficient K^{-1} K^{-1} temperature_gradient_t temperature_gradient K/m m^{-1} \\cdot K","title":"Library defined SI derived units and format"},{"location":"UserManual/si-derived-units/#library-defined-units-and-format","text":"","title":"Library defined units and format"},{"location":"UserManual/si-derived-units/#format-io","text":"std::ostream adaptor operator << is defined in header <dimensional/io.hpp> . example // begin example #include <dimensional/quantity.hpp> #include <dimensional/systems/si/all.hpp> #include <dimensional/io.hpp> int main () { using mitama :: quantity_t ; namespace si = mitama :: systems :: si ; quantity_t a = 1 | si :: meters ; std :: cout << a << '\\n' ; // 1 [m] } // end example","title":"Format IO"},{"location":"UserManual/si-derived-units/#si-basic-units","text":"type name quantifier name Unit symbol Quantity measured metre_t/meter_t metre/meter m length kilogram_t kilogram kg mass second_t second s time ampere_t ampere A electric current kelvin_t kelvin K temperature mole_t mole mol amount of substance candela_t candela cd luminous intensity","title":"SI basic units"},{"location":"UserManual/si-derived-units/#non-si-units","text":"type name quantifier name Unit symbol Equivalents in terms of SI units hectare_t hectare ha 1\\ ha = 10^4\\ m^2 litre_t/liter_t litre/liter L 1\\ L = 10^{-3}\\ m^3 tonne_t tonne t 1\\ t = 10^3\\ kg au_t au au 1\\ au = 149,597,870,700\\ m minute_t minutes min 1\\ min = 60\\ s hour_t hours h 1\\ h = 60\\ min = 3600\\ s day_t days d 1\\ d = 24\\ h = 86400\\ s","title":"Non SI units"},{"location":"UserManual/si-derived-units/#named-units-derived-from-si-base-units","text":"type name quantifier Name Symbol Quantity Equivalents SI base unit Equivalents hertz_t hertz Hz frequency 1/s s^{-1} radian_t radian rad angle m/m 1 steradian_t steradian sr solid angle m^2/m^2 1 newton_t newton N force weight kg \\cdot m/s^2 kg \\cdot m \\cdot s^{-2} pascal_t pascal Pa pressure stress N/m^2 kg \\cdot m^{-1} \\cdot s^{-2} joule_t joule J energy work heat N \\cdot m \\\\ C \\cdot V \\\\ W \\cdot s kg \\cdot m^2 \\cdot s^{-2} watt_t watt W power radiant flux J/s \\\\ V \\cdot A kg \\cdot m^2 \\cdot s^{-3} coulomb_t coulomb C electric charge quantity of electricity s \\cdot A \\\\ F \\cdot V s \\cdot A volt_t volt V voltage electrical potential difference W/A \\\\ J/C kg \\cdot m^2 \\cdot s^{-3} \\cdot A^{-1} farad_t farad F electrical capacitance C/V \\\\ s/\\Omega kg^{-1} \\cdot m^{-2} \\cdot s^4 \\cdot A^2 ohm_t ohm \\Omega electrical resistance impedance, reactance 1/S \\\\ V/A kg \\cdot m^2 \\cdot s^{-3} \\cdot A^{-2} siemens_t siemens S electrical conductance 1/\\Omega \\\\ A/V kg^{-1} \\cdot m^{-2} \\cdot s^3 \\cdot A^2 weber_t weber Wb magnetic flux J/A \\\\ T \\cdot m^2 kg \\cdot m^2 \\cdot s^{-2} \\cdot A^{-1} tesla_t tesla T magnetic induction magnetic flux density V \\cdot s/m^2 \\\\ Wb/m^2 \\\\ N/(A \\cdot m) kg \\cdot s^{-2} \\cdot A^{-1} henry_t henry H electrical inductance V \\cdot s/A \\\\ \\Omega \\cdot s \\\\ Wb/A kg \\cdot m^2 \\cdot s^{-2} \\cdot A^{-2} degree_celsius_t degree_celsius \u00b0C temperature relative to 273.15 K K K lumen_t lumen lm luminous flux cd \\cdot sr cd lux_t lux lx illuminance lm/m^2 m^{-2} \\cdot cd becquerel_t becquerel Bq radioactivity (decays per unit time) 1/s s^{-1} gray_t gray Gy absorbed dose (of ionizing radiation) J/kg m^2 \\cdot s^{-2} sievert_t sievert Sv equivalent dose (of ionizing radiation) J/kg m^2 \\cdot s^{-2} katal_t katal kat catalytic activity mol/s s^{-1} \\cdot mol","title":"Named units derived from SI base units"},{"location":"UserManual/si-derived-units/#kinematic-si-derived-units","text":"type name quantifier Name Symbol Expression in termsof SI base units velocity_t velocity m/s m \\cdot s^{-1} acceleration_t acceleration m/s^2 m \\cdot s^{-2} jerk_t jerk m/s^3 m \\cdot s^{-3} snap_t snap m/s^4 m \\cdot s^{-4} crackle_t crackle m/s^5 m \\cdot s^{-5} pop_t pop m/s^6 m \\cdot s^{-6} angular_velocity_t angular_velocity rad/s s^{-1} angular_acceleration_t angular_acceleration rad/s^2 s^{-2} frequency_drift_t frequency_drift Hz/s s^{-2} volumetric_flow_t volumetric_flow m^3/s m^3 \\cdot s^{-1}","title":"Kinematic SI derived units"},{"location":"UserManual/si-derived-units/#molar-si-derived-units","text":"type name quantifier Name Symbol Expression in terms of SI base units molarity_t molarity mol/m^3 m^{-3} \\cdot mol molar_volume_t molar_volume_t m^3/mol m^3 \\cdot mol^{-1} molar_entropy_t molar_entropy J/(K \\cdot mol) m^2 \\cdot kg \\cdot s^{-2} \\cdot K^{-1} \\cdot mol^{-1} molar_heat_capacity_t molar_heat_capacity J/(K \\cdot mol) m^2 \\cdot kg \\cdot s^{-2} \\cdot K^{-1} \\cdot mol^{-1} molar_energy_t molar_energy J/mol m^2 \\cdot kg \\cdot s^{-2} \\cdot mol^{-1} molar_conductivity_t molar_conductivity S \\cdot m^2/mol kg^{-1} \\cdot s^3 \\cdot A^2 \\cdot mol^{-1} molality_t molality mol/kg kg^{-1} \\cdot mol molar_mass_t molar_mass kg/mol kg \\cdot mol^{-1} catalytic_efficiency_t catalytic_efficiency m^3/(mol \\cdot s) m^3 \\cdot s^{-1} \\cdot mol^{-1}","title":"Molar SI derived units"},{"location":"UserManual/si-derived-units/#electromagnetic-si-derived-units","text":"type name quantifier Name Symbol Expression in terms of SI base units electric_displacement_field_t electric_displacement_field C/m^2 m^{-2} \\cdot s \\cdot A polarization_density_t polarization_density --- m^{-2} \\cdot s \\cdot A electric_charge_density_t electric_charge_density C/m^3 m^{-3} \\cdot s \\cdot A electric_current_density_t electric_current_density A/m^2 m^{-2} \\cdot A electrical_conductivity_t electrical_conductivity S/m m^{-3} \\cdot kg^{-1} \\cdot s^3 \\cdot A^2 permittivity_t permittivity F/m m^{-3} \\cdot kg^{-1} \\cdot s^4 \\cdot A^2 permeability_t permeability H/m m \\cdot kg \\cdot s^{-2} \\cdot A^{-2} electric_field_strength_t electric_field_strength V/m m \\cdot kg \\cdot s^{-3} \\cdot A^{-1} magnetization_t magnetization A/m m^{-1} \\cdot A exposure_t exposure C/kg kg^{-1} \\cdot s \\cdot A resistivity_t resistivity \\Omega \\cdot m m^3 \\cdot kg \\cdot s^{-3} \\cdot A^{-2} linear_charge_density_t linear_charge_density C/m m^{-1} \\cdot s \\cdot A magnetic_dipole_moment_t magnetic_dipole_moment --- m^2 \\cdot A electron_mobility_t electron_mobility m^2/(V \\cdot s) kg^{-1} \\cdot s^2 \\cdot A magnetic_reluctance_t magnetic_reluctance H^{-1} m^{-2} \\cdot kg^{-1} \\cdot s^2 \\cdot A^2 magnetic_vector_potential_t magnetic_vector_potential Wb/m m \\cdot kg \\cdot s^{-2} \\cdot A^{-1} magnetic_moment_t magnetic_moment Wb \\cdot m m^3 \\cdot kg \\cdot s^{-2} \\cdot A^{-1} magnetic_rigidity_t magnetic_rigidity T \\cdot m m \\cdot kg \\cdot s^{-2} \\cdot A^{-1} magnetomotive_force_t magnetomotive_force --- A magnetic_susceptibility_t magnetic_susceptibility m/H m^{-1} \\cdot kg^{-1} \\cdot s^2 \\cdot A^2","title":"Electromagnetic SI derived units"},{"location":"UserManual/si-derived-units/#photometric-si-derived-units","text":"type name quantifier Name Symbol Expression in terms of SI base units luminous_energy_t luminous_energy lm \\cdot s s \\cdot cd \\cdot sr luminous_exposure_t luminous_energy lx \\cdot s m^{-2} \\cdot s \\cdot cd \\cdot sr luminance_t luminous_energy cd/m^2 m^{-2} \\cdot cd luminous_efficacy_t luminous_energy lm/W m^{-2} \\cdot kg^{-1} \\cdot s^3 \\cdot cd \\cdot sr","title":"Photometric SI derived units"},{"location":"UserManual/si-derived-units/#thermodynamic-si-derived-units","text":"type name quantifier Name Symbol Expression in terms of SI base units heat_capacity_t specific_entropy J/K m^2 \\cdot kg \\cdot s^{-2} \\cdot K^{-1} entropy_t entropy J/K m^2 \\cdot kg \\cdot s^{-2} \\cdot K^{-1} specific_heat_capacity_t specific_heat_capacity J/(K \\cdot kg) m^2 \\cdot s^{-2} \\cdot K^{-1} specific_entropy_t specific_entropy J/(K \\cdot kg) m^2 \\cdot s^{-2} \\cdot K^{-1} thermal_conductivity_t thermal_conductivity W/(m \\cdot K) m \\cdot kg \\cdot s^{-3} \\cdot K^{-1} thermal_resistance_t thermal_resistance K/W m^{-2} \\cdot kg^{-1} \\cdot s^3 \\cdot K thermal_expansion_coefficient_t thermal_expansion_coefficient K^{-1} K^{-1} temperature_gradient_t temperature_gradient K/m m^{-1} \\cdot K","title":"Thermodynamic SI derived units"},{"location":"UserManual/static-quantity/","text":"Static quantity Motivation Q. What are the benefits of treating quantity at compile time? A. Literal refinement at value level is possible at compile time. See bellow: // begin example #include <dimensional/quantity.hpp> #include <dimensional/static_quantity.hpp> #include <dimensional/systems/si/meter.hpp> #include <dimensional/io.hpp> #include <iostream> // predicate examples: template < auto Arg > struct is_even : std :: bool_constant < Arg % 2 == 0 > {}; int main (){ using mitama :: systems :: si :: meter_t ; using mitama :: static_quantity , mitama :: refined , mitama :: quantity_t ; using namespace mitama :: literals :: static_quantity_literals ; constexpr refined < is_even , quantity_t < meter_t , int >> r = 2 _m ; // ^~~~~~~ ^~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~ ^~~~ // | | | | // | | refined type UDL for static_quantity // | | // | refinement predicate // | // refinement type // It is a compilation error because a specified predicate `is_even` is not satisfied: // constexpr refined<is_even, quantity_t<meter_t, int>> error_ = 3_m; } // end example class static_quantity_t definition template < class , auto > struct static_quantity_t ; template < class ... Units , template < class > class Synonym , auto Value > struct static_quantity_t < Synonym < dimensional_t < Units ... >> , Value > { using value_type = decltype ( Value ); using dimension_type = dimensional_t < Units ... > ; static constexpr value_type value = Value ; }; static_quantity_t is a class for pure compile-time quantity manipulation. The idea of static quantity is almost same as std::integral_constant . C++17 introduced declaring non-type template parameters with auto . So, static_quantity_t is declared as static_quantity_t<class Dim, auto Value> . Use values \u200b\u200bdirectly in the template as in static_quantity_t<meter_t, 2> . static_quantity - a variable template definition template < class Dim , auto Value > inline constexpr static_quantity_t < Dim , Value > static_quantity {}; For long time, C++ meta-programmer using class for compile-time manipulation. Like below: // for example // from: https://github.com/nholthaus/units#pure-compile-time-unit-manipulation struct RightTriangle { using a = unit_value_t < meters , 3 > ; using b = unit_value_t < meters , 4 > ; using c = unit_value_sqrt < unit_value_add < unit_value_power < a , 2 > , unit_value_power < b , 2 > > > ; }; That is elephant. Using constexpr variable template is elegant solution. // Value level metaprogramming. // Awesome!! static_quantity < meter_t , 1 > + static_quantity < meter_t , 1 > ; // -> static_quantity<meter_t, 2> This technique used in Boost.Hana . Provided operations for static_quantity : operator + operator - operator * operator / pow<N> Static quantity literals Introduce UDLs to make static quantities more convenient. Since static_quantity can only be used as a literal, the description can be shortened by using UDLs. definition (for example) namespace mitama :: literals { inline namespace static_quantity_literals { inline namespace length_literals { template < char ... Chars > inline constexpr static_quantity_t < mitama :: systems :: si :: meter_t , static_cast < int > ( mitamagic :: to_decimal_v < Chars ... > ) > operator \"\" _m () { return {}; } } }} Using UDLs, the above code can be rewritten as follows: using namespace mitama :: literals :: static_quantity_literals ; 1 _m + 1 _m ; // amazing!!! // -> 2_m (= static_quantity<meter_t, 2>) Refinement type for static quantities definition template < template < auto > class , class T > class refined ; template < template < auto > class Pred , class Dim , class T > class refined < Pred , quantity_t < Dim , T >> { quantity_t < Dim , T > quantity_ ; public : template < auto Value , class Dimension , std :: enable_if_t < std :: conjunction_v < std :: is_constructible < quantity_t < Dim , T > , quantity_t < Dimension , decltype ( Value ) >> , Pred < Value >> , bool > = false > constexpr refined ( static_quantity_t < Dimension , Value > ) noexcept : quantity_ ( quantity_t < Dimension , decltype ( Value ) > ( Value )) {} }; The predicate must be a class template with auto as a template parameter. This is typically write as follows: template < auto A > struct is_positive : std :: bool_constant < ( A > - 1 ) > {}; Refined quantity conversion Refined quantity is convertible to quantity_t . quantity_t constructor quantity_t<D1, T> has constructor from refined<Pred, quantity_t<E, U>> . This constructor shall not participates in overload resolution unless is_same_dimensional_v<D, E> is true and std::is_convertible_v<U, T> is true. Units conversion is automatically performed. quantity_t's deduction guide for refined > quantity_t provides deduction guide for refined: template < template < auto > class Pred , class Dim , class T > quantity_t ( refined < Pred , quantity_t < Dim , T >> ) -> quantity_t < Dim , T > ; Therefore, you can infer template parameters as follows: refined < is_positive , quantity_t < si :: meter_t , int >> x = 42 _m ; quantity_t y = x ; // y: quantity_t<si::meter_t, int>","title":"Static quantity"},{"location":"UserManual/static-quantity/#static-quantity","text":"","title":"Static quantity"},{"location":"UserManual/static-quantity/#motivation","text":"Q. What are the benefits of treating quantity at compile time? A. Literal refinement at value level is possible at compile time. See bellow: // begin example #include <dimensional/quantity.hpp> #include <dimensional/static_quantity.hpp> #include <dimensional/systems/si/meter.hpp> #include <dimensional/io.hpp> #include <iostream> // predicate examples: template < auto Arg > struct is_even : std :: bool_constant < Arg % 2 == 0 > {}; int main (){ using mitama :: systems :: si :: meter_t ; using mitama :: static_quantity , mitama :: refined , mitama :: quantity_t ; using namespace mitama :: literals :: static_quantity_literals ; constexpr refined < is_even , quantity_t < meter_t , int >> r = 2 _m ; // ^~~~~~~ ^~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~ ^~~~ // | | | | // | | refined type UDL for static_quantity // | | // | refinement predicate // | // refinement type // It is a compilation error because a specified predicate `is_even` is not satisfied: // constexpr refined<is_even, quantity_t<meter_t, int>> error_ = 3_m; } // end example","title":"Motivation"},{"location":"UserManual/static-quantity/#class-static_quantity_t","text":"definition template < class , auto > struct static_quantity_t ; template < class ... Units , template < class > class Synonym , auto Value > struct static_quantity_t < Synonym < dimensional_t < Units ... >> , Value > { using value_type = decltype ( Value ); using dimension_type = dimensional_t < Units ... > ; static constexpr value_type value = Value ; }; static_quantity_t is a class for pure compile-time quantity manipulation. The idea of static quantity is almost same as std::integral_constant . C++17 introduced declaring non-type template parameters with auto . So, static_quantity_t is declared as static_quantity_t<class Dim, auto Value> . Use values \u200b\u200bdirectly in the template as in static_quantity_t<meter_t, 2> .","title":"class static_quantity_t"},{"location":"UserManual/static-quantity/#static_quantity-a-variable-template","text":"definition template < class Dim , auto Value > inline constexpr static_quantity_t < Dim , Value > static_quantity {}; For long time, C++ meta-programmer using class for compile-time manipulation. Like below: // for example // from: https://github.com/nholthaus/units#pure-compile-time-unit-manipulation struct RightTriangle { using a = unit_value_t < meters , 3 > ; using b = unit_value_t < meters , 4 > ; using c = unit_value_sqrt < unit_value_add < unit_value_power < a , 2 > , unit_value_power < b , 2 > > > ; }; That is elephant. Using constexpr variable template is elegant solution. // Value level metaprogramming. // Awesome!! static_quantity < meter_t , 1 > + static_quantity < meter_t , 1 > ; // -> static_quantity<meter_t, 2> This technique used in Boost.Hana . Provided operations for static_quantity : operator + operator - operator * operator / pow<N>","title":"static_quantity - a variable template"},{"location":"UserManual/static-quantity/#static-quantity-literals","text":"Introduce UDLs to make static quantities more convenient. Since static_quantity can only be used as a literal, the description can be shortened by using UDLs. definition (for example) namespace mitama :: literals { inline namespace static_quantity_literals { inline namespace length_literals { template < char ... Chars > inline constexpr static_quantity_t < mitama :: systems :: si :: meter_t , static_cast < int > ( mitamagic :: to_decimal_v < Chars ... > ) > operator \"\" _m () { return {}; } } }} Using UDLs, the above code can be rewritten as follows: using namespace mitama :: literals :: static_quantity_literals ; 1 _m + 1 _m ; // amazing!!! // -> 2_m (= static_quantity<meter_t, 2>)","title":"Static quantity literals"},{"location":"UserManual/static-quantity/#refinement-type-for-static-quantities","text":"definition template < template < auto > class , class T > class refined ; template < template < auto > class Pred , class Dim , class T > class refined < Pred , quantity_t < Dim , T >> { quantity_t < Dim , T > quantity_ ; public : template < auto Value , class Dimension , std :: enable_if_t < std :: conjunction_v < std :: is_constructible < quantity_t < Dim , T > , quantity_t < Dimension , decltype ( Value ) >> , Pred < Value >> , bool > = false > constexpr refined ( static_quantity_t < Dimension , Value > ) noexcept : quantity_ ( quantity_t < Dimension , decltype ( Value ) > ( Value )) {} }; The predicate must be a class template with auto as a template parameter. This is typically write as follows: template < auto A > struct is_positive : std :: bool_constant < ( A > - 1 ) > {};","title":"Refinement type for static quantities"},{"location":"UserManual/static-quantity/#refined-quantity-conversion","text":"Refined quantity is convertible to quantity_t . quantity_t constructor quantity_t<D1, T> has constructor from refined<Pred, quantity_t<E, U>> . This constructor shall not participates in overload resolution unless is_same_dimensional_v<D, E> is true and std::is_convertible_v<U, T> is true. Units conversion is automatically performed. quantity_t's deduction guide for refined > quantity_t provides deduction guide for refined: template < template < auto > class Pred , class Dim , class T > quantity_t ( refined < Pred , quantity_t < Dim , T >> ) -> quantity_t < Dim , T > ; Therefore, you can infer template parameters as follows: refined < is_positive , quantity_t < si :: meter_t , int >> x = 42 _m ; quantity_t y = x ; // y: quantity_t<si::meter_t, int>","title":"Refined quantity conversion"},{"location":"UserManual/user-defined-dimension/","text":"How to define dimension class \"Fear of a C++ only increases fear of the thing itself.\" dimension type All that is required to behave as a dimension type is to define a void type alias named is_base_dimension as a type member. struct wizarding_currency { using is_base_dimension = void ; }; Base unit type Use mitama::make_unit_t to get base unit types from dimension types. using knut_t = mitama :: make_unit_t < wizarding_currency > ; Scaled unit type Use mtiama::make_unit_t to get scaled unit types from base unit types. using sickle_t = mitama :: scaled_unit_t < knut_t , std :: ratio < 29 >> ; using galleon_t = mitama :: scaled_unit_t < sickle_t , std :: ratio < 17 >> ; Dimensional quantifiers [option] inline constexpr knut_t knuts {}; inline constexpr knut_t knut {}; inline constexpr sickle_t sickles {}; inline constexpr sickle_t sickle {}; inline constexpr galleon_t galleons {}; inline constexpr galleon_t galleon {}; Format [option] Define specializations to enable formatted output. namespace mitama { template <> struct abbreviation < wizarding :: knut_t > { static constexpr char str [] = \"knuts\" ; }; template <> struct abbreviation < wizarding :: sickle_t > { static constexpr char str [] = \"sickles\" ; }; template <> struct abbreviation < wizarding :: galleon_t > { static constexpr char str [] = \"galleons\" ; }; }","title":"User define dimension"},{"location":"UserManual/user-defined-dimension/#how-to-define-dimension-class","text":"\"Fear of a C++ only increases fear of the thing itself.\"","title":"How to define dimension class"},{"location":"UserManual/user-defined-dimension/#dimension-type","text":"All that is required to behave as a dimension type is to define a void type alias named is_base_dimension as a type member. struct wizarding_currency { using is_base_dimension = void ; };","title":"dimension type"},{"location":"UserManual/user-defined-dimension/#base-unit-type","text":"Use mitama::make_unit_t to get base unit types from dimension types. using knut_t = mitama :: make_unit_t < wizarding_currency > ;","title":"Base unit type"},{"location":"UserManual/user-defined-dimension/#scaled-unit-type","text":"Use mtiama::make_unit_t to get scaled unit types from base unit types. using sickle_t = mitama :: scaled_unit_t < knut_t , std :: ratio < 29 >> ; using galleon_t = mitama :: scaled_unit_t < sickle_t , std :: ratio < 17 >> ;","title":"Scaled unit type"},{"location":"UserManual/user-defined-dimension/#dimensional-quantifiers-option","text":"inline constexpr knut_t knuts {}; inline constexpr knut_t knut {}; inline constexpr sickle_t sickles {}; inline constexpr sickle_t sickle {}; inline constexpr galleon_t galleons {}; inline constexpr galleon_t galleon {};","title":"Dimensional quantifiers [option]"},{"location":"UserManual/user-defined-dimension/#format-option","text":"Define specializations to enable formatted output. namespace mitama { template <> struct abbreviation < wizarding :: knut_t > { static constexpr char str [] = \"knuts\" ; }; template <> struct abbreviation < wizarding :: sickle_t > { static constexpr char str [] = \"sickles\" ; }; template <> struct abbreviation < wizarding :: galleon_t > { static constexpr char str [] = \"galleons\" ; }; }","title":"Format [option]"}]}